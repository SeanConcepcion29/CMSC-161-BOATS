<!DOCTYPE html>
<html>
  <head>
    <title> B.O.A.T.S. </title>
    <link rel="stylesheet" href="styles.css">

    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;   

      attribute vec2 aOffset;
      uniform float uTime;

      uniform mat4 uModelMatrix;                
      uniform mat4 uViewMatrix;                 
      uniform mat4 uProjectionMatrix;           

      uniform mat4 uNormalMatrix;              
      
      uniform vec4 uMaterialDiffuseColor;     
      uniform vec4 uMaterialSpecularColor;  
      uniform vec4 uMaterialAmbientColor;     

      uniform vec4 uLightColor;    

      uniform vec4 uLightDirectionVector;      
      uniform vec4 uEyeVector;                 
      uniform vec4 uReflectedLightVector;    
      
      uniform float uSpecularStrength;
      uniform float uAmbientStrength;

      varying vec4 vAmbientColor;

      varying vec4 vSpecularColor;

      varying vec4 vDiffuseColor;

      void main() {
        
  
        //Ambient
        vec4 ambient = uAmbientStrength * uLightColor;

        //Diffuse
        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);
        float lambertCoefficient = max(dot(normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        //Specular
        vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
        vec4 normalized_uEyeVector = normalize(-viewPos); 
        vec4 normalized_uReflectedLightVector = normalize(2.0 * dot(normalized_uLightDirectionVector,normalized_aNormalVector) * normalized_aNormalVector - normalized_uLightDirectionVector);
        float specularAngle = max(dot(normalized_uEyeVector,normalized_uReflectedLightVector),0.0);
        float specular = pow(specularAngle, 16.0);

        vec4 ambientColor = ambient * uLightColor * uMaterialDiffuseColor;
        vec4 specularColor = uSpecularStrength * specular * uLightColor * uMaterialDiffuseColor;
        vec4 diffuseColor =  lambertCoefficient * uLightColor * uMaterialDiffuseColor ;
        
        vAmbientColor = vec4(ambientColor.r, ambientColor.g, ambientColor.b, 1.0);
        vSpecularColor = vec4(specularColor.r, specularColor.g, specularColor.b, 1.0);
        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);

        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
      }
    </script>


    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fshader">

      precision mediump float;
      varying vec4 vDiffuseColor;
      varying vec4 vSpecularColor;
      varying vec4 vAmbientColor;

      void main() {
        gl_FragColor = vAmbientColor + vDiffuseColor + vSpecularColor;
        
      }

    </script>
    <!-- Imports external javascript file -->
    <!-- Helper javascript methods for initializing webgl -->
    <script src="lib/webgl-init.js"></script>
    <script src="lib/webgl-utils.js"></script>
    <script src="lib/webgl-debug.js"></script>
    <script src="lib/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webgl-obj-loader@2.0.8/dist/webgl-obj-loader.min.js"></script>


    <!-- Applies Poppins font to the entire body -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">
    <style> body { font-family: 'Poppins', sans-serif;} </style>


    <!-- FUNCTIONS & MAIN PROGRAM -->
    <script>

        // Global variable to hold the boat mesh.
        var mesh = null;

        // Function to load the OBJ file
        function loadWakeboard(gl) {
            var objStr = '';
            // For example, using fetch:
            fetch('models/wakeboard.obj')
                .then(response => response.text())
                .then(text => {
                    // Parse the OBJ file
                    var parsedObj = new OBJ.Mesh(text);
                    // Initialize WebGL buffers
                    mesh = OBJ.initMeshBuffers(gl, parsedObj);
                })
                .catch(error => console.error('Error loading OBJ file:', error));
        }
        
        /* MAIN PROGRAM */
        function main() {
        
            var canvas = document.getElementById("main_canvas");


            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            /* Sets up the WebGL rendering context */
            var gl = initializeWebGL(canvas, true);

            loadWakeboard(gl);

            /* Loads shaders */ 
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");

            /* Creates and sets the program created earlier */
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            /* Creates and links program */
            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPositionPointer);

            var aNormalPointer = gl.getAttribLocation(program, "aNormal");
            gl.enableVertexAttribArray(aNormalPointer);

            /* Retrieves the location of the model, view, and projection from the shader program */
            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
            var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");

            var modelMatrix = mat4.create();
            var viewMatrix;
            var projectionMatrix;

            /* Makes the screen transparent */
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /* Enable depth testing */
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT);


            /* Sets up projection matrix specification */
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 100;

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));


            /* Sets up view matrix specification */
            var lookAtPoint = [0.0, 0.0, 0.0, 1.0]; 
            var upVector = [0.0, 1.0, 0.0, 0.0]; 





            /* Function for changing the values of the view position */
            function updateEyePosition() {

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var eyePoint = [eyeX, eyeY, eyeZ, 1.0]; 

                /* Updates the view matrix */
                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
            }

            updateEyePosition();

            /* Function for updating eye postion based on key press */
            function updateEyeOnKeydown(event){

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var step = 1;

                switch (event.key) {
                  case 'ArrowLeft':   // Move left (along X-axis)
                      eyeX -= step;
                      break;
                  case 'ArrowRight':  // Move right
                      eyeX += step;
                      break;
                  case 'ArrowUp':     // Move up (along Y-axis)
                      eyeY += step;
                      break;
                  case 'ArrowDown':   // Move down
                      eyeY -= step;
                      break;
                }

                /* Update input values in HTML */
                document.getElementById("eyeX").value = eyeX.toFixed(2);
                document.getElementById("eyeY").value = eyeY.toFixed(2);

                updateEyePosition();
            }

            /* Function for updating projection matrix */
            function updatePerspective(){
              /* Retrieves perspective from the input fields */
              fieldOfViewYAxis = glMatrix.toRadian(parseFloat(document.getElementById("zoomAngle").value));

              /* Updates Projection Matrix*/
              projectionMatrix = mat4.create();
              mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
              gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
            }

            updatePerspective()


            /* Function for updating zoom based on scroll */

            function updateEyeOnScroll(event) {
              event.preventDefault(); // Prevent page from scrolling

              var zoomAngle = parseFloat(document.getElementById("zoomAngle").value);
              
              var step = 1;
          
              // Scrolling up increases zoom (moves forward), down decreases zoom (moves back)
              if (event.deltaY < 0) {
                  zoomAngle -= step;
              } else {
                  zoomAngle += step;
              }

              // Update perspective
              document.getElementById("zoomAngle").value = zoomAngle.toFixed(2);

              updatePerspective()
            }

            /* Initializes model matrix (identity) */
            modelMatrix = mat4.create();
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            /* Adds normal matrix */
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

            /* Sets up light and material parameters */
            var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 0.850, 1.0, 1.0);

            

            /* Function for changing the values of the light components (RGB) */
            function updateLightColor() {

                /* Retrieves the light components (RGB) from the input fields */
                var lightR = parseFloat(document.getElementById("lightR").value);
                var lightG = parseFloat(document.getElementById("lightG").value);
                var lightB = parseFloat(document.getElementById("lightB").value);

                var lightColor = [lightR, lightG, lightB, 1.0];

                /* Updates the light color */
                var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightColor");
                gl.uniform4fv(uLightDiffuseColorPtr, new Float32Array(lightColor));
            }

            updateLightColor()

            /* Function for changing the values of the light direction */
            function updateLightDirection() {
                var lightX = parseFloat(document.getElementById("lightX").value);
                var lightY = parseFloat(document.getElementById("lightY").value);
                var lightZ = parseFloat(document.getElementById("lightZ").value);

                var lightDirection = [lightX, lightY, lightZ, 0.0];
                
                console.log(lightX, lightY, lightZ);

                /* Updates the light direction  */
                var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
                gl.uniform4fv(uLightDirectionVectorPtr, new Float32Array(lightDirection));
            }

            updateLightDirection()


            /* Retrieve location of specular and ambient strength to update light intensity */
            var uSpecularStrengthPtr = gl.getUniformLocation(program, "uSpecularStrength");
            var uAmbientStrengthPtr = gl.getUniformLocation(program, "uAmbientStrength");

            /* Function to set light intensity based on time of day */
            var currentTime = new Date();
            var currentHour = currentTime.getHours(); 

            function updateLightIntensity(){

              // If time is between 6 AM to 5 PM, set light intensity to bright
              if(currentHour < 18 && currentHour >= 6){
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                // Change button text to NIGHT
                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }

              // If time is between 6 PM to 5 AM, set light intensity to dim
              else{
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                // Change button text to DAY
                document.querySelector("#lightingbtn").innerText = "DAY";
              }
            }
            
            updateLightIntensity();


            /* Sets up coordinates for the object */
            var vertices = [  
    
                /* Front face */
                -1.0, -1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,

                /* Back face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,

                /* Top face */
                -1.0,  1.0, -1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,

                /* Bottom face */
                -1.0, -1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,

                /* Right face */
                1.0, -1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,

                /* Left face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0
            ];


            /* Binds the vertex buffer and load data */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            
            /* Sets up the indices of the vertices */
            var indices = [
                0, 1, 2,      0, 2, 3,    
                4, 5, 6,      4, 6, 7,    
                8, 9, 10,     8, 10, 11,  
                12, 13, 14,   12, 14, 15, 
                16, 17, 18,   16, 18, 19, 
                20, 21, 22,   20, 22, 23  
            ];       


            /* Binds the index buffer and load data */
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        
            /* Sets up the normals of the vertices */
            var normals = [  
                0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,  // front
                0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,  // front
                0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,  // front
                0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,  // front
                1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,  // right
                -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0   // left
            ];

            /* Binds the normal buffer and load data */
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            /* Sets up normal attribute pointer */
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            /* Vertex buffer for waves */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);
            



            /* Variables for wave animation */
            let startTime = performance.now(); 
            let waveEnabled = false;

            /* Function for toggling rotation on button press */
            function toggleAnimation() {
              waveEnabled = !waveEnabled;
              if(waveEnabled) { document.querySelector("#animationbtn").innerText = "OFF"; }
              else if(!waveEnabled) { document.querySelector("#animationbtn").innerText = "ON"; }
            }

            window.toggleAnimation = toggleAnimation;
            
            // Calculate wave height at position (x,z) at time elapsedTime
            function getWaveHeight(x, z, elapsedTime) {
                return Math.sin(elapsedTime * 2.0 + (x + z)) * 0.5;
            }

            // Calculate wave normal at position (x,z) at time elapsedTime
            function getWaveNormal(x, z, elapsedTime) {
                // Calculate partial derivatives to get the normal
                const delta = 0.1;
                const h = getWaveHeight(x, z, elapsedTime);
                const hx = getWaveHeight(x + delta, z, elapsedTime) - h;
                const hz = getWaveHeight(x, z + delta, elapsedTime) - h;
                
                // Return normal vector (pointing upwards)
                return [-hx, 1.0, -hz];
            }

           // Draw the boat
           function renderBoat(elapsedTime = 0) {
                if (!mesh) return;

                // Common boat transformations
                let boatModelMatrix = mat4.create();
                
                if (waveEnabled) {
                    // Wave-enabled boat
                    let boatY = 1.23 + Math.sin(elapsedTime * 2.0) * 0.2;
                    mat4.translate(boatModelMatrix, boatModelMatrix, [0, boatY + 0.5, 0]);
                    let wavePhase = elapsedTime * 2.0;
                    let rockAngle = Math.sin(wavePhase * 1.3) * 0.1;
                    mat4.rotateZ(boatModelMatrix, boatModelMatrix, rockAngle);
                } else {
                   // Static boat with gentle bobbing
                    let boatY = 1.5 + Math.sin(elapsedTime * 0.5) * 0.1; // Reduced amplitude and slower frequency
                    mat4.translate(boatModelMatrix, boatModelMatrix, [0, boatY, 1]);
                    let rockAngle = Math.sin(elapsedTime * 0.3) * 0.1; // Very slight rocking
                    mat4.rotateZ(boatModelMatrix, boatModelMatrix, rockAngle);
                }

                // Common scaling and rotation
                mat4.scale(boatModelMatrix, boatModelMatrix, [0.015, 0.015, 0.015]);
                mat4.rotateX(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90));
                
                gl.uniformMatrix4fv(uModelMatrixPointer, false, boatModelMatrix);
                
                let boatNormalMatrix = mat4.create();
                mat4.invert(boatNormalMatrix, boatModelMatrix);
                mat4.transpose(boatNormalMatrix, boatNormalMatrix);
                gl.uniformMatrix4fv(uNormalMatrixPtr, false, boatNormalMatrix);
                
                // Bind boat buffers
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
                
                gl.drawElements(gl.TRIANGLES, mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            }


            /* Function for rendering the objects on canvas*/
            function render() {
                const elapsedTime = performance.now() / 1000;

                /* Clears screen */
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


                /* Draw the boat first */
                if (waveEnabled) {     
                  const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                  const originalColor = [0.0, 0.850, 1.0, 1.0];
                  gl.uniform4f(originalColorPtr, 0.7, 0.7, 0.7, 1.0);
                  renderBoat(elapsedTime); 
                  gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
                } 

                else {
                    const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                    const originalColor = [0.0, 0.850, 1.0, 1.0];
                    gl.uniform4f(originalColorPtr, 0.7, 0.7, 0.7, 1.0);
                    renderBoat(elapsedTime);  
                    gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
                }
            


                /* Now draw the wave cubes */
                gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                for (let i = 0; i < 12; i++) {
                    for (let j = 0; j < 12; j++) {

                        let tempModelMatrix = mat4.clone(modelMatrix);

                        /* Determines wave height */
                        let waveHeight = 0;
                        if (waveEnabled) {
                            waveHeight = Math.sin(elapsedTime * 2.0 + (i + j)) * 0.5;
                        }

                        /* Moves the cube into correct position */
                        mat4.translate(tempModelMatrix, tempModelMatrix, [
                            (i - 5) ,  
                            waveHeight,
                            (j - 5) ,   
                        ]);

                        /* Applies scaling to shrink the cubes */
                        let scaleMatrix = mat4.create();

                        mat4.scale(scaleMatrix, scaleMatrix, [0.5, 0.5, 0.5]);
                        mat4.multiply(tempModelMatrix, tempModelMatrix, scaleMatrix);

                        /* Updates normal matrix */
                        gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(tempModelMatrix));


                        let tempNormalMatrix = mat4.create();
                        mat4.invert(tempNormalMatrix, tempModelMatrix);
                        mat4.transpose(tempNormalMatrix, tempNormalMatrix);

                        gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(tempNormalMatrix));


                        /* Draws the cube */
                        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
                    }
                }

                requestAnimationFrame(render);
            }

            render();

            if(currentHour < 18 && currentHour >= 6){
              var daylight = true; 
            }
            else{
              var daylight = false;
            }
            

            function toggleLighting() {
              daylight = !daylight;

              if(daylight){
                // Change background to white
                gl.clearColor(0.0, 0.0, 0.0, 0.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }
              else{
                 // Change background to dark gray
                gl.clearColor(0.3, 0.3, 0.3, 1.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                document.querySelector("#lightingbtn").innerText = "DAY";
              }

              // Update light after setting values
              updateLightDirection();
            };

            window.toggleLighting = toggleLighting;
            
            

            /* Retrieves values of the input sliders */
            document.getElementById("eyeX").addEventListener("input", updateEyePosition);
            document.getElementById("eyeY").addEventListener("input", updateEyePosition);
            document.getElementById("eyeZ").addEventListener("input", updateEyePosition);

            document.getElementById("lightX").addEventListener("input", updateLightDirection);
            document.getElementById("lightY").addEventListener("input", updateLightDirection);
            document.getElementById("lightZ").addEventListener("input", updateLightDirection);

            document.getElementById("lightR").addEventListener("input", updateLightColor);
            document.getElementById("lightG").addEventListener("input", updateLightColor);
            document.getElementById("lightB").addEventListener("input", updateLightColor);

            document.getElementById("zoomAngle").addEventListener("input", updatePerspective);

            /* Event Listeners for input */
            document.addEventListener('keydown', updateEyeOnKeydown)
            document.addEventListener('wheel', updateEyeOnScroll, { passive: false });

            
              
        }

    
    </script>

  </head>

  <body onload="main()">
    <div class="container">
  
      <!-- Sidebar -->
      <div class="sidebar">
        <img src="boats-logo.PNG" alt="Wave Simulation" class="logo">
  
        <label class="section-title-btn">SIMULATE WAVE</label>
        <button id="animationbtn" onclick="toggleAnimation()">ON</button>
  
        <div class="section">
          <label class="section-title">EYE POSITION</label>

          <label for="eyeX">X</label>
          <input type="range" id="eyeX" step="0.1" min="-20" max="25" value="25"><br/>
  
          <label for="eyeY">Y</label>
          <input type="range" id="eyeY" step="0.1" min="-20" max="20" value="17"><br/>
  
          <label for="eyeZ">Z</label>
          <input type="range" id="eyeZ" step="0.1" min="-20" max="20" value="-20"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">ZOOM</label>
          <label for="zoomAngle">Z</label>
          <input type="range" id="zoomAngle" step="0.1" min="5" max="40" value="20">
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT DIRECTION</label>

          <label for="lightX">X</label>
          <input type="range" id="lightX" step="0.1" min="-20" max="20" value="1.0"><br/>
  
          <label for="lightY">Y</label>
          <input type="range" id="lightY" step="0.1" min="-20" max="20" value="3.0"><br/>
  
          <label for="lightZ">Z</label>
          <input type="range" id="lightZ" step="0.1" min="-20" max="20" value="5.0"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT COLOR</label>
          <label for="lightR" class="color-label red">R</label>
          <input type="range" id="lightR" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightG" class="color-label green">G</label>
          <input type="range" id="lightG" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightB" class="color-label blue">B</label>
          <input type="range" id="lightB" step="0.05" min="0" max="1" value="1"><br/>
        </div>
  
        <label class="section-title-btn">SET TIME TO </label>
        <button id="lightingbtn" onclick="toggleLighting()">DAY</button>
      </div>
  
      <!-- Canvas area -->
      <div class="canvas-container">
        <canvas id="main_canvas" width="1600" height="900"></canvas>
      </div>
  
    </div>
  </body>

</html>



<!-- REFERENCES -->

<!-- 1 | Wave Animation -->
<!-- https://stackoverflow.com/questions/23417139/programmatically-make-a-wave-using-javascript -->
<!-- https://gist.github.com/gkhays/e264009c0832c73d5345847e673a64ab -->