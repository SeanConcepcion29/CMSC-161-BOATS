<!DOCTYPE html>
<html>
  <head>
    <title> B.O.A.T.S. </title>


    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;   

      uniform mat4 uModelMatrix;                
      uniform mat4 uViewMatrix;                 
      uniform mat4 uProjectionMatrix;           

      uniform mat4 uNormalMatrix;              
      
      uniform vec4 uMaterialDiffuseColor;     
      uniform vec4 uMaterialSpecularColor;  
      uniform vec4 uMaterialAmbientColor;     

      uniform vec4 uLightColor;    

      uniform vec4 uLightDirectionVector;      
      uniform vec4 uEyeVector;                 
      uniform vec4 uReflectedLightVector;    
      
      uniform float uSpecularStrength;
      uniform float uAmbientStrength;

      varying vec4 vAmbientColor;

      varying vec4 vSpecularColor;

      varying vec4 vDiffuseColor;

      void main() {
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
  
        //Ambient
        vec4 ambient = uAmbientStrength * uLightColor;

        //Diffuse
        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);
        float lambertCoefficient = max(dot(normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        //Specular
        vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
        vec4 normalized_uEyeVector = normalize(-viewPos); 
        vec4 normalized_uReflectedLightVector = normalize(2.0 * dot(normalized_uLightDirectionVector,normalized_aNormalVector) * normalized_aNormalVector - normalized_uLightDirectionVector);
        float specularAngle = max(dot(normalized_uEyeVector,normalized_uReflectedLightVector),0.0);
        float specular = pow(specularAngle, 16.0);

        vec4 ambientColor = ambient * uLightColor * uMaterialDiffuseColor;
        vec4 specularColor = uSpecularStrength * specular * uLightColor * uMaterialDiffuseColor;
        vec4 diffuseColor =  lambertCoefficient * uLightColor * uMaterialDiffuseColor ;
        
        vAmbientColor = vec4(ambientColor.r, ambientColor.g, ambientColor.b, 1.0);
        vSpecularColor = vec4(specularColor.r, specularColor.g, specularColor.b, 1.0);
        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
      }
    </script>


    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fshader">

      precision mediump float;
      varying vec4 vDiffuseColor;
      varying vec4 vSpecularColor;
      varying vec4 vAmbientColor;

      void main() {
        gl_FragColor = vAmbientColor + vDiffuseColor + vSpecularColor;
        
      }

    </script>


    <!-- Imports external javascript file -->
    <!-- Helper javascript methods for initializing webgl -->
    <script src="lib/webgl-init.js"></script>
    <script src="lib/webgl-utils.js"></script>
    <script src="lib/webgl-debug.js"></script>
    <script src="lib/gl-matrix-min.js"></script>


    <!-- Applies Poppins font to the entire body -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">
    <style> body { font-family: 'Poppins', sans-serif;} </style>


    <!-- FUNCTIONS & MAIN PROGRAM -->
    <script>

        /* MAIN PROGRAM */
        function main() {
        
            var canvas = document.getElementById("main_canvas");

            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            /* Sets up the WebGL rendering context */
            var gl = initializeWebGL(canvas, true);

            /* Loads shaders */
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");

            /* Creates and sets the program created earlier */
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            /* Creates and links program */
            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPositionPointer);

            var aNormalPointer = gl.getAttribLocation(program, "aNormal");
            gl.enableVertexAttribArray(aNormalPointer);

            /* Retrieves the location of the model, view, and projection from the shader program */
            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
            var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");

            var modelMatrix = mat4.create();
            var viewMatrix;
            var projectionMatrix;

            /* Makes the screen transparent */
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /* Enable depth testing */
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT);


            /* Sets up projection matrix specification */
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 100;

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));


            /* Sets up view matrix specification */
            var lookAtPoint = [0.0, 0.0, 0.0, 1.0]; 
            var upVector = [0.0, 1.0, 0.0, 0.0]; 





            /* Function for changing the values of the view position */
            function updateEyePosition() {

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var eyePoint = [eyeX, eyeY, eyeZ, 1.0]; 

                /* Updates the view matrix */
                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
            }

            updateEyePosition();

            /* Function for updating eye postion based on key press */
            function updateEyeOnKeydown(event){

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var step = 1;

                switch (event.key) {
                  case 'ArrowLeft':   // Move left (along X-axis)
                      eyeX -= step;
                      break;
                  case 'ArrowRight':  // Move right
                      eyeX += step;
                      break;
                  case 'ArrowUp':     // Move up (along Y-axis)
                      eyeY += step;
                      break;
                  case 'ArrowDown':   // Move down
                      eyeY -= step;
                      break;
                }

                /* Update input values in HTML */
                document.getElementById("eyeX").value = eyeX.toFixed(2);
                document.getElementById("eyeY").value = eyeY.toFixed(2);

                updateEyePosition();
            }

            /* Function for updating projection matrix */
            function updatePerspective(){
              /* Retrieves perspective from the input fields */
              fieldOfViewYAxis = glMatrix.toRadian(parseFloat(document.getElementById("zoomAngle").value));

              /* Updates Projection Matrix*/
              projectionMatrix = mat4.create();
              mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
              gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
            }

            updatePerspective()


            /* Function for updating zoom based on scroll */

            function updateEyeOnScroll(event) {
              event.preventDefault(); // Prevent page from scrolling

              var zoomAngle = parseFloat(document.getElementById("zoomAngle").value);
              
              var step = 1;
          
              // Scrolling up increases zoom (moves forward), down decreases zoom (moves back)
              if (event.deltaY < 0) {
                  zoomAngle -= step;
              } else {
                  zoomAngle += step;
              }

              // Update perspective
              document.getElementById("zoomAngle").value = zoomAngle.toFixed(2);

              updatePerspective()
            }



            /* Initializes model matrix (identity) */
            modelMatrix = mat4.create();
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            /* Adds normal matrix */
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

            /* Sets up light and material parameters */
            var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 0.850, 1.0, 1.0);

            

            /* Function for changing the values of the light components (RGB) */
            function updateLightColor() {

                /* Retrieves the light components (RGB) from the input fields */
                var lightR = parseFloat(document.getElementById("lightR").value);
                var lightG = parseFloat(document.getElementById("lightG").value);
                var lightB = parseFloat(document.getElementById("lightB").value);

                var lightColor = [lightR, lightG, lightB, 1.0];

                /* Updates the light color */
                var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightColor");
                gl.uniform4fv(uLightDiffuseColorPtr, new Float32Array(lightColor));
            }

            updateLightColor()





            /* Function for changing the values of the light direction */
            function updateLightDirection() {
                var lightX = parseFloat(document.getElementById("lightX").value);
                var lightY = parseFloat(document.getElementById("lightY").value);
                var lightZ = parseFloat(document.getElementById("lightZ").value);

                var lightDirection = [lightX, lightY, lightZ, 0.0];
                
                console.log(lightX, lightY, lightZ);

                /* Updates the light direction  */
                var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
                gl.uniform4fv(uLightDirectionVectorPtr, new Float32Array(lightDirection));
            }

            updateLightDirection()


            /* Retrieve location of specular and ambient strength to update light intensity */
            var uSpecularStrengthPtr = gl.getUniformLocation(program, "uSpecularStrength");
            var uAmbientStrengthPtr = gl.getUniformLocation(program, "uAmbientStrength");

            /* Function to set light intensity based on time of day */
            var currentTime = new Date();
            var currentHour = currentTime.getHours(); 

            function updateLightIntensity(){

              // If time is between 6 AM to 5 PM, set light intensity to bright
              if(currentHour < 18 && currentHour >= 6){
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                // Change button text to NIGHT
                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }

              // If time is between 6 PM to 5 AM, set light intensity to dim
              else{
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                // Change button text to DAY
                document.querySelector("#lightingbtn").innerText = "DAY";
              }
            }
            
            updateLightIntensity();


            /* Sets up coordinates for the object */
            var vertices = [  
    
                /* Front face */
                -1.0, -1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,

                /* Back face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,

                /* Top face */
                -1.0,  1.0, -1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,

                /* Bottom face */
                -1.0, -1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,

                /* Right face */
                1.0, -1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,

                /* Left face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0
            ];


            /* Binds the vertex buffer and load data */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            
            /* Sets up the indices of the vertices */
            var indices = [
                0, 1, 2,      0, 2, 3,    
                4, 5, 6,      4, 6, 7,    
                8, 9, 10,     8, 10, 11,  
                12, 13, 14,   12, 14, 15, 
                16, 17, 18,   16, 18, 19, 
                20, 21, 22,   20, 22, 23  
            ];       


            /* Binds the index buffer and load data */
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        
            /* Sets up the normals of the vertices */
            var normals = [  
                0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,  // front
                0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,  // front
                0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,  // front
                0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,  // front
                1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,  // right
                -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0   // left
            ];

            var boatVertices = [
              // Bottom (flipped Y)
              -1.0,  0.6,  2.0, 1.0,
              1.0,  0.6,  2.0, 1.0,
              1.0,  0.6, -2.0, 1.0,
              -1.0,  0.6, -2.0, 1.0,

              // Sides (flipped Y)
              -1.0,  0.6,  2.0, 1.0,
              -1.0, -0.5,  1.0, 1.0,
              -1.0, -0.5, -1.0, 1.0,
              -1.0,  0.6, -2.0, 1.0,

              1.0,  0.6,  2.0, 1.0,
              1.0, -0.5,  1.0, 1.0,
              1.0, -0.5, -1.0, 1.0,
              1.0,  0.6, -2.0, 1.0,

              // Front (flipped Y)
              -1.0,  0.6,  2.0, 1.0,
              1.0,  0.6,  2.0, 1.0,
              1.0, -0.5,  1.0, 1.0,
              -1.0, -0.5,  1.0, 1.0,

              // Back (flipped Y)
              -1.0,  0.6, -2.0, 1.0,  
              1.0,  0.6, -2.0, 1.0,   
              1.0, -0.5, -1.0, 1.0,   
              -1.0, -0.5, -1.0, 1.0,

              // Top (flipped Y)
              -1.0, -0.5,  1.0, 1.0,
              1.0, -0.5,  1.0, 1.0,
              1.0, -0.5, -1.0, 1.0,
              -1.0, -0.5, -1.0, 1.0
          ];

            var boatNormals = [
                // Bottom (facing down)
                0.0, -1.0, 0.0, 0.0,
                0.0, -1.0, 0.0, 0.0,
                0.0, -1.0, 0.0, 0.0,
                0.0, -1.0, 0.0, 0.0,
                
                // Left side
                -1.0, 0.0, 0.0, 0.0,
                -1.0, 0.0, 0.0, 0.0,
                -1.0, 0.0, 0.0, 0.0,
                -1.0, 0.0, 0.0, 0.0,
                
                // Right side
                1.0, 0.0, 0.0, 0.0,
                1.0, 0.0, 0.0, 0.0,
                1.0, 0.0, 0.0, 0.0,
                1.0, 0.0, 0.0, 0.0,
                
                // Top
                0.0, 1.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,

                // Front
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                0.0, 0.0, 1.0, 0.0,

                // Back
                0.0, 0.0, -1.0, 0.0,
                0.0, 0.0, -1.0, 0.0,
                0.0, 0.0, -1.0, 0.0,
                0.0, 0.0, -1.0, 0.0,
                ];

                // Boat indices (triangles)
              var boatIndices = [
                // Bottom
                0, 1, 2, 0, 2, 3,
                // Left side
                7, 6, 4, 6, 5, 4,
                // Right side
                11, 10, 8, 10, 9, 8,
                // Top
                12, 13, 14, 12, 14, 15,

                // Front
                12, 13, 14,
                12, 14, 15,

                // Back
                16, 17, 18,
                16, 18, 19
                ];

            /* Binds the normal buffer and load data */
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            /* Sets up normal attribute pointer */
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            // Boat vertex buffer initialization
            var boatVertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boatVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(boatVertices), gl.STATIC_DRAW);

            // Boat normal buffer initialization
            var boatNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boatNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, boatNormals, gl.STATIC_DRAW);

            // Boat index buffer initialization
            var boatIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boatIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(boatIndices), gl.STATIC_DRAW);

            /* Vertex buffer for waves */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            

            /* Variables for wave animation */
            let startTime = Date.now(); 
            let waveEnabled = false;

            /* Function for toggling rotation on button press */
            function toggleAnimation() {
              waveEnabled = !waveEnabled;
            }

            window.toggleAnimation = toggleAnimation;


            /* Function for rendering the objects on canvas*/
            function render() {
                const now = Date.now();
                const elapsedTime = (now - startTime) / 1000; 

                mat4.identity(modelMatrix); 

                

                /* Clears screen */
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


                /* Draw the boat first (if waves are enabled) */
                if (waveEnabled) {
                  const boatBob = Math.sin(elapsedTime * 2.0) * 0.05;
                  const boatX = 0;
                  const boatZ = 0;
                  const waveUnderBoat = Math.sin(elapsedTime * 2.0) * 0.5;
                  
                  // Save original material color
                  const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                  const originalColor = [0.0, 0.850, 1.0, 1.0];
                  
                  // Set boat color (brown)
                  gl.uniform4f(originalColorPtr, 0.55, 0.27, 0.07, 1.0);
                  
                  // Boat hull (hollow structure)
                  for (let i = 0; i < 8; i++) { // length
                      for (let j = 0; j < 5; j++) { // width
                          // Only draw outer walls
                          if (j === 0 || j === 4 || i === 0 || i === 7) {
                              let tempModelMatrix = mat4.clone(modelMatrix);
                              
                              mat4.translate(tempModelMatrix, tempModelMatrix, [
                                  boatX + (j - 2) * 0.6,
                                  waveUnderBoat + 1.0 + boatBob, // taller height
                                  boatZ + (i - 3.5) * 0.6
                              ]);
                              
                              let scaleMatrix = mat4.create();
                              // Taller and narrower cubes for hull
                              mat4.scale(scaleMatrix, scaleMatrix, [0.6, 0.8, 0.6]);
                              mat4.multiply(tempModelMatrix, tempModelMatrix, scaleMatrix);
                              
                              gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(tempModelMatrix));
                              
                              let tempNormalMatrix = mat4.create();
                              mat4.invert(tempNormalMatrix, tempModelMatrix);
                              mat4.transpose(tempNormalMatrix, tempNormalMatrix);
                              gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(tempNormalMatrix));
                              
                              gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
                          }
                      }
                  }
                  
                  // Restore original material color for waves
                  gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
              }

              if (!waveEnabled) {
                  const boatBob = Math.sin((elapsedTime * 2) * 2.0) * 0.05;
                  const boatX = 0;
                  const boatZ = 0;
                  const waveUnderBoat = Math.sin(elapsedTime * 2.0) * 0.05;
                  
                  // Save original material color
                  const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                  const originalColor = [0.0, 0.850, 1.0, 1.0];
                  
                  // Set boat color (brown)
                  gl.uniform4f(originalColorPtr, 0.55, 0.27, 0.07, 1.0);
                  
                  // Boat hull (hollow structure)
                  for (let i = 0; i < 8; i++) { // length
                      for (let j = 0; j < 5; j++) { // width
                          // Only draw outer walls
                          if (j === 0 || j === 4 || i === 0 || i === 7) {
                              let tempModelMatrix = mat4.clone(modelMatrix);
                              
                              mat4.translate(tempModelMatrix, tempModelMatrix, [
                                  boatX + (j - 2) * 0.6,
                                  waveUnderBoat + 1.0 + boatBob, 
                                  boatZ + (i - 3.5) * 0.6
                              ]);
                              
                              let scaleMatrix = mat4.create();
                              // Taller and narrower cubes for hull
                              mat4.scale(scaleMatrix, scaleMatrix, [0.6, 0.8, 0.6]);
                              mat4.multiply(tempModelMatrix, tempModelMatrix, scaleMatrix);
                              
                              gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(tempModelMatrix));
                              
                              let tempNormalMatrix = mat4.create();
                              mat4.invert(tempNormalMatrix, tempModelMatrix);
                              mat4.transpose(tempNormalMatrix, tempNormalMatrix);
                              gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(tempNormalMatrix));
                              
                              gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
                          }
                      }
                  }
                  
                  // Restore original material color for waves
                  gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
              }


                /* Now draw the wave cubes */
                gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                for (let i = 0; i < 12; i++) {
                    for (let j = 0; j < 12; j++) {

                        let tempModelMatrix = mat4.clone(modelMatrix);

                        /* Determines wave height */
                        let waveHeight = 0;
                        if (waveEnabled) {
                            waveHeight = Math.sin(elapsedTime * 2.0 + (i + j)) * 0.5;
                        }

                        /* Moves the cube into correct position */
                        mat4.translate(tempModelMatrix, tempModelMatrix, [
                            (i - 5) ,  
                            waveHeight,
                            (j - 5) ,   
                        ]);

                        /* Applies scaling to shrink the cubes */
                        let scaleMatrix = mat4.create();

                        mat4.scale(scaleMatrix, scaleMatrix, [0.5, 0.5, 0.5]);
                        mat4.multiply(tempModelMatrix, tempModelMatrix, scaleMatrix);

                        /* Updates normal matrix */
                        gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(tempModelMatrix));


                        let tempNormalMatrix = mat4.create();
                        mat4.invert(tempNormalMatrix, tempModelMatrix);
                        mat4.transpose(tempNormalMatrix, tempNormalMatrix);

                        gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(tempModelMatrix));


                        /* Draws the cube */
                        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
                    }
                }

                requestAnimationFrame(render);
            }

            render();

            if(currentHour < 18 && currentHour >= 6){
              var daylight = true; 
            }
            else{
              var daylight = false;
            }
            

            function toggleLighting() {
              daylight = !daylight;

              if(daylight){
                // Change background to white
                gl.clearColor(0.0, 0.0, 0.0, 0.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }
              else{
                 // Change background to dark gray
                gl.clearColor(0.3, 0.3, 0.3, 1.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                document.querySelector("#lightingbtn").innerText = "DAY";
              }

              // Update light after setting values
              updateLightDirection();
            };

            window.toggleLighting = toggleLighting;
            
            

            /* Retrieves values of the input sliders */
            document.getElementById("eyeX").addEventListener("input", updateEyePosition);
            document.getElementById("eyeY").addEventListener("input", updateEyePosition);
            document.getElementById("eyeZ").addEventListener("input", updateEyePosition);

            document.getElementById("lightX").addEventListener("input", updateLightDirection);
            document.getElementById("lightY").addEventListener("input", updateLightDirection);
            document.getElementById("lightZ").addEventListener("input", updateLightDirection);

            document.getElementById("lightR").addEventListener("input", updateLightColor);
            document.getElementById("lightG").addEventListener("input", updateLightColor);
            document.getElementById("lightB").addEventListener("input", updateLightColor);


            // document.getElementById("lightingbtn").addEventListener("click", toggleLighting);

            /* Event Listeners for input */
            document.addEventListener('keydown', updateEyeOnKeydown)
            document.addEventListener('wheel', updateEyeOnScroll, { passive: false });

            
              
        }

    
    </script>

  </head>



  <body onload="main()" style="margin: 0; height: 100%; overflow: hidden;">
    <div style="display: flex;">

      <!-- Left side: User Interface Card -->
      <div style="width: 300px; background-color: #f9f9f9; padding: 20px;  overflow-y: auto;">

        <img src="boats-logo.PNG" alt="Wave Simulation" style="width: 100%; margin-top: 20px; border-radius: 8px;"><br>

        <label style="margin-right: 5px; font-weight: bold;">SIMULATE WAVE</label>
        <button style="margin-right: 30px;" onclick="toggleAnimation()">ON</button>

        <br><br>

        <!-- Sliders for changing eye position -->
        <label style="margin-right: 20px; font-weight: bold;">EYE POSITION</label><br>

        <label for="eyeX">X</label>
        <input type="range" id="eyeX" step="0.1" min="-20" max="25" value="25" style="margin-right: 10px;"><br>

        <label for="eyeY">Y</label>
        <input type="range" id="eyeY" step="0.1" min="-20" max="20" value="17" style="margin-right: 10px;"><br>

        <label for="eyeZ">Z</label>
        <input type="range" id="eyeZ" step="0.1" min="-20" max="20" value="-20" style="margin-right: 10px;"><br><br>


        <!-- Sliders for changing zoom -->
        <label style="margin-right: 20px; font-weight: bold;">ZOOM</label><br>

        <label for="zoomAngle">Z</label>
        <input type="range" id="zoomAngle" step="0.1" min="5" max="40" value="20" style="margin-right: 10px;"><br><br>

        <!-- Sliders for changing light position -->
        <label style="margin-right: 20px; font-weight: bold;">LIGHT DIRECTION</label><br>

        <label for="lightX">X</label>
        <input type="range" id="lightX" step="0.1" min="-20" max="20" value="1.0" style="margin-right: 10px;"><br>

        <label for="lightY">Y</label>
        <input type="range" id="lightY" step="0.1" min="-20" max="20" value="3.0" style="margin-right: 10px;"><br>

        <label for="lightZ">Z</label>
        <input type="range" id="lightZ" step="0.1" min="-20" max="20" value="5.0" style="margin-right: 10px;"><br><br>


        <!-- Sliders for changing light color -->
        <label style="margin-right: 20px; font-weight: bold;">LIGHT COLOR</label><br>

        <label for="lightR" style="color: red;">R</label>
        <input type="range" id="lightR" step="0.05" min="0" max="1" value="0.5" style="margin-right: 10px;"><br>

        <label for="lightG" style="color: green;">G</label>
        <input type="range" id="lightG" step="0.05" min="0" max="1" value="1" style="margin-right: 10px;"><br>

        <label for="lightB" style="color: blue;">B</label>
        <input type="range" id="lightB" step="0.05" min="0" max="1" value="1" style="margin-right: 10px;"><br><br>

        <label style="margin-right: 5px; font-weight: bold;">SET TIME TO: </label>
        <button style="margin-right: 30px;"  id="lightingbtn" onclick="toggleLighting()">DAY</button>

      </div>

      <!-- Right side: Canvas -->
      <div style="flex-grow: 1; display: flex; justify-content: center; align-items: center; height: 100vh;">
        <canvas id="main_canvas" width="1600" height="900" ></canvas>
      </div>
    </div>
  </body>

</html>



<!-- REFERENCES -->

<!-- 1 | Wave Animation -->
<!-- https://stackoverflow.com/questions/23417139/programmatically-make-a-wave-using-javascript -->
<!-- https://gist.github.com/gkhays/e264009c0832c73d5345847e673a64ab -->