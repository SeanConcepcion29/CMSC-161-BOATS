<!DOCTYPE html>
<html>
<head>
    <title> B.O.A.T.S. </title>


    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vshader">
    attribute vec4 aPosition;
    attribute vec4 aNormal;   

    uniform mat4 uModelMatrix;                
    uniform mat4 uViewMatrix;                 
    uniform mat4 uProjectionMatrix;           

    uniform mat4 uNormalMatrix;              
    
    uniform vec4 uMaterialDiffuseColor;       
    uniform vec4 uLightDiffuseColor;          
    uniform vec4 uLightDirectionVector;   

    varying vec4 vDiffuseColor;

    void main() {
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;

        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        vec4 diffuseColor =  uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;
        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
    }
    </script>


    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fshader">
    precision mediump float;
    varying vec4 vDiffuseColor;
    
    void main() {
        gl_FragColor = vDiffuseColor;
    }
    </script>

    </script>
    <!-- Imports external javascript file -->
    <!-- Helper javascript methods for initializing webgl -->
    <script src="lib/webgl-init.js"></script>
    <script src="lib/webgl-utils.js"></script>
    <script src="lib/webgl-debug.js"></script>
    <script src="lib/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webgl-obj-loader@2.0.8/dist/webgl-obj-loader.min.js"></script>


    <!-- Applies Poppins font to the entire body -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">
    <style> body { font-family: 'Poppins', sans-serif;} </style>


    <!-- FUNCTIONS & MAIN PROGRAM -->
    <script>

        // Global variable to hold the boat mesh.
        var mesh = null;

        // Function to load the OBJ file
        function loadWakeboard(gl) {
            var objStr = '';
            // For example, using fetch:
            fetch('models/wakeboard.obj')
                .then(response => response.text())
                .then(text => {
                    // Parse the OBJ file
                    var parsedObj = new OBJ.Mesh(text);
                    // Initialize WebGL buffers
                    mesh = OBJ.initMeshBuffers(gl, parsedObj);
                })
                .catch(error => console.error('Error loading OBJ file:', error));
        }
        
        /* MAIN PROGRAM */
        function main() {
        
            var canvas = document.getElementById("main_canvas");


            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            /* Sets up the WebGL rendering context */
            var gl = initializeWebGL(canvas, true);

            loadWakeboard(gl);

            /* Loads shaders */ 
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");

            /* Creates and sets the program created earlier */
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            /* Creates and links program */
            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPositionPointer);

            var aNormalPointer = gl.getAttribLocation(program, "aNormal");
            gl.enableVertexAttribArray(aNormalPointer);

            /* Retrieves the location of the model, view, and projection from the shader program */
            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
            var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");

            var modelMatrix = mat4.create();
            var viewMatrix;
            var projectionMatrix;

            /* Makes the screen transparent */
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /* Enable depth testing */
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT);


            /* Sets up projection matrix specification */
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 100;

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));


            /* Sets up view matrix specification */
            var lookAtPoint = [0.0, 0.0, 0.0, 1.0]; 
            var upVector = [0.0, 1.0, 0.0, 0.0]; 





            /* Function for changing the values of the view position */
            function updateEyePosition() {

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var eyePoint = [eyeX, eyeY, eyeZ, 1.0]; 

                /* Updates the view matrix */
                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
            }

            updateEyePosition();

            /* Function for updating eye postion based on key press */
            function updateEyeOnKeydown(event){

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var step = 1;

                switch (event.key) {
                case 'ArrowLeft':  // Move left (along X-axis)
                    eyeX -= step;
                    break;
                case 'ArrowRight': // Move right
                    eyeX += step;
                    break;
                case 'ArrowUp':          // Move up (along Y-axis)
                    eyeY += step;
                    break;
                case 'ArrowDown':          // Move down
                    eyeY -= step;
                    break;
                }

                /* Update input values in HTML */
                document.getElementById("eyeX").value = eyeX.toFixed(2);
                document.getElementById("eyeY").value = eyeY.toFixed(2);

                updateEyePosition();
            }

            /* Function for updating eye postion based on scroll */
            function updateEyeOnScroll(event) {
            event.preventDefault(); // Prevent page from scrolling
            
            var eyeZ = parseFloat(document.getElementById("eyeZ").value);
            
            var step = 1;
        
            // Scrolling up decreases Z (moves forward), down increases Z (moves back)
            if (event.deltaY < 0) {
                eyeZ += step;
            } else {
                eyeZ -= step;
            }
        
            document.getElementById("eyeZ").value = eyeZ.toFixed(2);

            updateEyePosition();
        }





            /* Initializes model matrix (identity) */
            modelMatrix = mat4.create();
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            /* Adds normal matrix */
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

            /* Sets up light and material parameters */
            var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 0.850, 1.0, 1.0);

            

            /* Function for changing the values of the light components (RGB) */
            function updateLightColor() {

                /* Retrieves the light components (RGB) from the input fields */
                var lightR = parseFloat(document.getElementById("lightR").value);
                var lightG = parseFloat(document.getElementById("lightG").value);
                var lightB = parseFloat(document.getElementById("lightB").value);

                var lightColor = [lightR, lightG, lightB, 1.0];

                /* Updates the light color */
                var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
                gl.uniform4fv(uLightDiffuseColorPtr, new Float32Array(lightColor));
            }

            updateLightColor()





            /* Function for changing the values of the light direction */
            function updateLightDirection() {
                var lightX = parseFloat(document.getElementById("lightX").value);
                var lightY = parseFloat(document.getElementById("lightY").value);
                var lightZ = parseFloat(document.getElementById("lightZ").value);

                var lightDirection = [lightX, lightY, lightZ, 0.0];

                /* Updates the light direction  */
                var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
                gl.uniform4fv(uLightDirectionVectorPtr, new Float32Array(lightDirection));
            }

            updateLightDirection()




            /* Sets up coordinates for the object */
            var vertices = [  
    
                /* Front face */
                -1.0, -1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,

                /* Back face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,

                /* Top face */
                -1.0,  1.0, -1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,

                /* Bottom face */
                -1.0, -1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,

                /* Right face */
                1.0, -1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,

                /* Left face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0
            ];

            
            /* Sets up the indices of the vertices */
            var indices = [
                0, 1, 2,      0, 2, 3,    
                4, 5, 6,      4, 6, 7,    
                8, 9, 10,     8, 10, 11,  
                12, 13, 14,   12, 14, 15, 
                16, 17, 18,   16, 18, 19, 
                20, 21, 22,   20, 22, 23  
            ];       


            /* Binds the index buffer and load data */
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        
            /* Sets up the normals of the vertices */
            var normals = [  
                0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,  // front
                0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,  // front
                0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,  // front
                0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,  // front
                1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,  // right
                -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0   // left
            ];


            /* Binds the normal buffer and load data */
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            /* Sets up normal attribute pointer */
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            /* Vertex buffer for waves */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);


            /* Variables for wave animation */
            let startTime = Date.now(); 
            let waveEnabled = false;

            /* Function for toggling rotation on button press */
            function toggleAnimation() {
            waveEnabled = !waveEnabled;
            }

            window.toggleAnimation = toggleAnimation;
            
            // Calculate wave height at position (x,z) at time elapsedTime
            function getWaveHeight(x, z, elapsedTime) {
                return Math.sin(elapsedTime * 2.0 + (x + z)) * 0.5;
            }

            // Calculate wave normal at position (x,z) at time elapsedTime
            function getWaveNormal(x, z, elapsedTime) {
                // Calculate partial derivatives to get the normal
                const delta = 0.1;
                const h = getWaveHeight(x, z, elapsedTime);
                const hx = getWaveHeight(x + delta, z, elapsedTime) - h;
                const hz = getWaveHeight(x, z + delta, elapsedTime) - h;
                
                // Return normal vector (pointing upwards)
                return [-hx, 1.0, -hz];
            }

           // Draw the boat
           function renderBoat(elapsedTime = 0) {
                if (!mesh) return;

                // Common boat transformations
                let boatModelMatrix = mat4.create();
                
                if (waveEnabled) {
                    // Wave-enabled boat
                    let boatY = 1.23 + Math.sin(elapsedTime * 2.0) * 0.2;
                    mat4.translate(boatModelMatrix, boatModelMatrix, [0, boatY + 0.5, 0]);
                    let wavePhase = elapsedTime * 2.0;
                    let rockAngle = Math.sin(wavePhase * 1.3) * 0.1;
                    mat4.rotateZ(boatModelMatrix, boatModelMatrix, rockAngle);
                } else {
                    // Static boat - position it higher and further back
                    mat4.translate(boatModelMatrix, boatModelMatrix, [0, 2.5, -2]);
                }

                // Common scaling and rotation
                mat4.scale(boatModelMatrix, boatModelMatrix, [0.02, 0.02, 0.02]);
                mat4.rotateX(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90));
                
                gl.uniformMatrix4fv(uModelMatrixPointer, false, boatModelMatrix);
                
                let boatNormalMatrix = mat4.create();
                mat4.invert(boatNormalMatrix, boatModelMatrix);
                mat4.transpose(boatNormalMatrix, boatNormalMatrix);
                gl.uniformMatrix4fv(uNormalMatrixPtr, false, boatNormalMatrix);
                
                // Bind boat buffers
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
                
                gl.drawElements(gl.TRIANGLES, mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
            }


            /* Function for rendering the objects on canvas*/
            function render() {
                const now = Date.now();
                const elapsedTime = (now - startTime) / 1000; 
                mat4.identity(modelMatrix); 

                /* Clears screen */
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                /* Draw the boat first (if waves are enabled) */
                if (waveEnabled) {
                  
                //   // Save original material color
                  const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                  const originalColor = [0.0, 0.850, 1.0, 1.0];
                  
                  // Set boat color (purple)
                  gl.uniform4f(originalColorPtr, 0.85, 0., 0.85, 1.0);
                    renderBoat(elapsedTime); // Pass elapsedTime here
                  // Restore original material color for waves
                  gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
                } 
                else {
            // Draw static boat when waves are off
            const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            const originalColor = [0.0, 0.850, 1.0, 1.0];
            gl.uniform4f(originalColorPtr, 0.55, 0.27, 0.07, 1.0);
            renderBoat(0);  
            gl.uniform4fv(originalColorPtr, new Float32Array(originalColor));
        }
              


                /* Now draw the wave cubes */
                gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                for (let i = 0; i < 12; i++) {
                    for (let j = 0; j < 12; j++) {
                        let tempModelMatrix = mat4.clone(modelMatrix);

                        /* Determines wave height */
                        let waveHeight = 0;
                        if (waveEnabled) {
                            waveHeight = Math.sin(elapsedTime * 2.0 + (i + j)) * 0.5;
                        }

                        /* Moves the cube into correct position */
                        mat4.translate(tempModelMatrix, tempModelMatrix, [
                            (i - 5),  
                            waveHeight,
                            (j - 5)
                        ]);

                        /* Applies scaling to shrink the cubes */
                        let scaleMatrix = mat4.create();
                        mat4.scale(scaleMatrix, scaleMatrix, [0.5, 0.5, 0.5]);
                        mat4.multiply(tempModelMatrix, tempModelMatrix, scaleMatrix);

                        /* Updates normal matrix */
                        gl.uniformMatrix4fv(uModelMatrixPointer, false, tempModelMatrix);

                        let tempNormalMatrix = mat4.create();
                        mat4.invert(tempNormalMatrix, tempModelMatrix);
                        mat4.transpose(tempNormalMatrix, tempNormalMatrix);
                        gl.uniformMatrix4fv(uNormalMatrixPtr, false, tempNormalMatrix);

                        /* Draws the cube */
                        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
                    }
                }

                requestAnimationFrame(render);
            }
            render();

            /* Retrieves values of the input sliders */
            document.getElementById("eyeX").addEventListener("input", updateEyePosition);
            document.getElementById("eyeY").addEventListener("input", updateEyePosition);
            document.getElementById("eyeZ").addEventListener("input", updateEyePosition);

            document.getElementById("lightX").addEventListener("input", updateLightDirection);
            document.getElementById("lightY").addEventListener("input", updateLightDirection);
            document.getElementById("lightZ").addEventListener("input", updateLightDirection);

            document.getElementById("lightR").addEventListener("input", updateLightColor);
            document.getElementById("lightG").addEventListener("input", updateLightColor);
            document.getElementById("lightB").addEventListener("input", updateLightColor);
            

            /* Event Listeners for input */
            document.addEventListener('keydown', updateEyeOnKeydown)
            document.addEventListener('wheel', updateEyeOnScroll, { passive: false });
        }

    
    </script>
</head>



<body onload="main()" style="margin: 0; height: 100%; overflow: hidden;">
    <div style="display: flex;">

    <!-- Left side: User Interface Card -->
    <div style="width: 300px; background-color: #f9f9f9; padding: 20px;  overflow-y: auto;">

        <img src="boats-logo.PNG" alt="Wave Simulation" style="width: 100%; margin-top: 20px; border-radius: 8px;"><br>

        <label style="margin-right: 5px; font-weight: bold;">SIMULATE WAVE</label>
        <button style="margin-right: 30px;" onclick="toggleAnimation()">ON</button>

        <br><br>

        <!-- Sliders for changing eye position -->
        <label style="margin-right: 20px; font-weight: bold;">EYE POSITION</label><br>

        <label for="eyeX">X</label>
        <input type="range" id="eyeX" step="0.1" min="-20" max="25" value="25" style="margin-right: 10px;"><br>

        <label for="eyeY">Y</label>
        <input type="range" id="eyeY" step="0.1" min="-20" max="20" value="17" style="margin-right: 10px;"><br>

        <label for="eyeZ">Z</label>
        <input type="range" id="eyeZ" step="0.1" min="-20" max="20" value="-20" style="margin-right: 10px;"><br><br>


        <!-- Sliders for changing light position -->
        <label style="margin-right: 20px; font-weight: bold;">LIGHT DIRECTION</label><br>

        <label for="lightX">X</label>
        <input type="range" id="lightX" step="0.1" min="-20" max="20" value="-1.0" style="margin-right: 10px;"><br>

        <label for="lightY">Y</label>
        <input type="range" id="lightY" step="0.1" min="-20" max="20" value="-3.0" style="margin-right: 10px;"><br>

        <label for="lightZ">Z</label>
        <input type="range" id="lightZ" step="0.1" min="-20" max="20" value="-5.0" style="margin-right: 10px;"><br><br>


        <!-- Sliders for changing light color -->
        <label style="margin-right: 20px; font-weight: bold;">LIGHT COLOR</label><br>

        <label for="lightR" style="color: red;">R</label>
        <input type="range" id="lightR" step="0.05" min="0" max="1" value="0.5" style="margin-right: 10px;"><br>

        <label for="lightG" style="color: green;">G</label>
        <input type="range" id="lightG" step="0.05" min="0" max="1" value="1" style="margin-right: 10px;"><br>

        <label for="lightB" style="color: blue;">B</label>
        <input type="range" id="lightB" step="0.05" min="0" max="1" value="1" style="margin-right: 10px;"><br><br>
    </div>

    <!-- Right side: Canvas -->
    <div style="flex-grow: 1; display: flex; justify-content: center; align-items: center; height: 100vh;">
        <canvas id="main_canvas" width="1600" height="900" ></canvas>
    </div>
    </div>
</body>
</html>



<!-- REFERENCES -->

<!-- 1 | Wave Animation -->
<!-- https://stackoverflow.com/questions/23417139/programmatically-make-a-wave-using-javascript -->
<!-- https://gist.github.com/gkhays/e264009c0832c73d5345847e673a64ab -->