<!DOCTYPE html>
<html>
  <head>
    <title> B.O.A.T.S. </title>
    <link rel="stylesheet" href="styles.css">

    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;
         
      attribute vec2 aTexCoord;  // Add texture coordinate attribute
      attribute vec2 aInstancePosition;
      uniform float uTime;
      // uniform vec3 uScale; 

      uniform bool uUseWave;


      uniform mat4 uModelMatrix;                
      uniform mat4 uViewMatrix;                 
      uniform mat4 uProjectionMatrix;           

      uniform mat4 uNormalMatrix;              
      
      uniform vec4 uMaterialDiffuseColor;     
      uniform vec4 uMaterialSpecularColor;  
      uniform vec4 uMaterialAmbientColor;     

      uniform vec4 uLightColor;    

      uniform vec4 uLightDirectionVector;      
      uniform vec4 uEyeVector;                 
      uniform vec4 uReflectedLightVector;    
      
      uniform float uSpecularStrength;
      uniform float uAmbientStrength;

      varying vec4 vAmbientColor;

      varying vec4 vSpecularColor;

      varying vec4 vDiffuseColor;

      varying vec2 vTexCoord;  // Pass texture coordinates to fragment shader
      

      void main() {

        // Calculate wave height based on whether it is on or not.
        float wave1 = sin(uTime * 2.0 + aInstancePosition.x * 0.7 + aInstancePosition.y * 0.4);
        float wave2 = sin(uTime * 3.0 + aInstancePosition.x * 1.3 - aInstancePosition.y * 0.9);
        float wave3 = sin(uTime * 1.5 + aInstancePosition.x * 0.2 + aInstancePosition.y * 1.7);
        float waveHeight = uUseWave ? (wave1 * 0.3 + wave2 * 0.2 + wave3 * 0.1) : 0.0;


      








        // Apply instance position and wave height
        mat4 modelMatrix = uModelMatrix;
        modelMatrix[3].xyz += vec3(aInstancePosition.x, waveHeight, aInstancePosition.y);

        // Create instance translation
        mat4 instanceTranslate = mat4(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          aInstancePosition.x, waveHeight, aInstancePosition.y, 1.0
        );

        // Apply scaling
        /*mat4 scaleMatrix = mat4(
          uScale.x, 0.0, 0.0, 0.0,
          0.0, uScale.y, 0.0, 0.0,
          0.0, 0.0, uScale.z, 0.0,
          0.0, 0.0, 0.0, 1.0
        );*/
        // modelMatrix = modelMatrix * scaleMatrix;

        // Transform vertex position
        gl_Position = uProjectionMatrix * uViewMatrix * modelMatrix * aPosition;
          
        //Ambient
        vec4 ambient = uAmbientStrength * uLightColor;

        //Diffuse
        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);
        float lambertCoefficient = max(dot(normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        //Specular
        vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
        vec4 normalized_uEyeVector = normalize(-viewPos); 
        vec4 normalized_uReflectedLightVector = normalize(2.0 * dot(normalized_uLightDirectionVector,normalized_aNormalVector) * normalized_aNormalVector - normalized_uLightDirectionVector);
        float specularAngle = max(dot(normalized_uEyeVector,normalized_uReflectedLightVector),0.0);
        float specular = pow(specularAngle, 16.0);

        vec4 ambientColor = ambient * uLightColor * uMaterialDiffuseColor;
        vec4 specularColor = uSpecularStrength * specular * uLightColor * uMaterialDiffuseColor;
        vec4 diffuseColor =  lambertCoefficient * uLightColor * uMaterialDiffuseColor ;
        
        vAmbientColor = vec4(ambientColor.r, ambientColor.g, ambientColor.b, 1.0);
        vSpecularColor = vec4(specularColor.r, specularColor.g, specularColor.b, 1.0);
        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
        vTexCoord = aTexCoord;  // Pass texture coordinates to fragment shader

      }
    </script>


    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fshader">

      precision mediump float;
      varying vec4 vDiffuseColor;
      varying vec4 vSpecularColor;
      varying vec4 vAmbientColor;
      varying vec2 vTexCoord;
  
      uniform sampler2D uTexture;  // Texture sampler
      uniform bool uUseTexture;    // Flag to enable/disable texture

      void main() {
        if (uUseTexture) {
          // Get texture color and combine with lighting
          vec4 texColor = texture2D(uTexture, vTexCoord);
          gl_FragColor = (vAmbientColor + vDiffuseColor + vSpecularColor) * texColor;
        } else {
          gl_FragColor = vAmbientColor + vDiffuseColor + vSpecularColor;
        }
        
      }

    </script>
    <!-- Imports external javascript file -->
    <!-- Helper javascript methods for initializing webgl -->
    <script src="lib/webgl-init.js"></script>
    <script src="lib/webgl-utils.js"></script>
    <script src="lib/webgl-debug.js"></script>
    <script src="lib/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webgl-obj-loader@2.0.8/dist/webgl-obj-loader.min.js"></script>


    <!-- Applies Poppins font to the entire body -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">
    <style> body { font-family: 'Poppins', sans-serif;} </style>


    <!-- FUNCTIONS & MAIN PROGRAM -->
    <script>

        // Global variable to hold the boat mesh and boat vertices for texture mapping.
        var mesh = null;
        var boatVertices = null;
        var parsedObj = null;

        // Function to load the OBJ file
        function loadWakeboard(gl) {
            fetch('models/wakeboard.obj')
                .then(response => response.text())
                .then(text => {
                    parsedObj = new OBJ.Mesh(text);
                    boatVertices = parsedObj.vertices;
                    
                    // Initialize WebGL buffers
                    mesh = OBJ.initMeshBuffers(gl, parsedObj);

                    // Check if texture coordinates exist
                    if (parsedObj.textures && parsedObj.textures.length > 0) {
                        mesh.textureBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.textureBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(parsedObj.textures), gl.STATIC_DRAW);
                        mesh.hasTextureCoords = true; // Add this flag
                    } else {
                        mesh.hasTextureCoords = false; // Add this flag
                        console.warn("OBJ file has no texture coordinates");
                    }
                })
                .catch(error => console.error('Error loading OBJ file:', error));
        }
                            
        var boatTexture = null;
        var uUseTextureLocation = null;
        var uTextureLocation = null;


        // Load texture image file
        function loadTexture(gl, url) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            // Fill texture with a temporary color while image loads
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
                          new Uint8Array([255, 255, 255, 255]));
            
            const image = new Image();
            image.onload = function() {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                
                // Check if image is power of 2
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    gl.generateMipmap(gl.TEXTURE_2D);
                } else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            };
            image.src = url;
            return texture;
        }

        function isPowerOf2(value) {
            return (value & (value - 1)) === 0;
        }
        
        /* MAIN PROGRAM */
        function main() {

            var canvas = document.getElementById("main_canvas");


            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            /* Sets up the WebGL rendering context */
            var gl = initializeWebGL(canvas, true);

            loadWakeboard(gl);

           // const wakeboardTexture = loadTexture(gl, 'textures/white-wooden-texture-flooring-background.jpg');
           const wakeboardTexture = loadTexture(gl, 'textures/white-wooden-texture-flooring-background.jpg');

            

            /* Loads shaders */ 
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");

            /* Creates and sets the program created earlier */
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            /* Creates and links program */
            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            var texcoordLocation = gl.getAttribLocation(program, "aTexCoord");
            
            gl.enableVertexAttribArray(aPositionPointer);

            var aNormalPointer = gl.getAttribLocation(program, "aNormal");
            gl.enableVertexAttribArray(aNormalPointer);

            uUseTextureLocation = gl.getUniformLocation(program, 'uUseTexture');
            uTextureLocation = gl.getUniformLocation(program, 'uTexture');

            /* Retrieves the location of the model, view, and projection from the shader program */
            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
            var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");
            
            
            const aInstancePosition = gl.getAttribLocation(program, 'aInstancePosition');
            gl.enableVertexAttribArray(aInstancePosition);
            
            // const uScaleLocation = gl.getUniformLocation(program, "uScale");
            // gl.uniform3f(uScaleLocation, 0.5, 0.5, 0.5);
            
            var waveModelMatrix = mat4.create();
            mat4.scale(waveModelMatrix, waveModelMatrix, [0.5, 0.5, 0.5]); // Scale waves
            gl.uniformMatrix4fv(uModelMatrixPointer, false, waveModelMatrix);


            var modelMatrix = mat4.create();
            var viewMatrix;
            var projectionMatrix;

            /* Makes the screen transparent */
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /* Enable depth testing */
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT);


            /* Sets up projection matrix specification */
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 100;

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));

            /* Number of Wave Cubes Instanced */
            const instanceCount = 80;

            /* Sets up view matrix specification */

            // Dynamically calculate the center of the grid based on instanceCount
            const gridCenterX = (instanceCount - 1) / 2; // Center of the grid along X
            const gridCenterZ = (instanceCount - 1) / 2; // Center of the grid along Z
            var lookAtPoint = [gridCenterX - 5, 0.0, gridCenterZ - 5]; // Adjust for grid offset
            var upVector = [0.0, 1.0, 0.0, 0.0];

            /* Function for changing the values of the view position */
            function updateEyePosition() {

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var eyePoint = [eyeX, eyeY, eyeZ, 1.0]; 

                /* Updates the view matrix */
                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
            }

            updateEyePosition();

             /* Function for updating eye postion based on key press */
            function updateEyeOnKeydown(event){

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var step = 1;

                switch (event.key) {
                  case 'ArrowLeft':   // Move left (along X-axis)
                      eyeX -= step;
                      break;
                  case 'ArrowRight':  // Move right
                      eyeX += step;
                      break;
                  case 'ArrowUp':     // Move up (along Y-axis)
                      eyeY += step;
                      break;
                  case 'ArrowDown':   // Move down
                      eyeY -= step;
                      break;
                }

                /* Update input values in HTML */
                document.getElementById("eyeX").value = eyeX.toFixed(2);
                document.getElementById("eyeY").value = eyeY.toFixed(2);

                updateEyePosition();
            }

            /* Function for updating projection matrix */
            function updatePerspective(){
              /* Retrieves perspective from the input fields */
              fieldOfViewYAxis = glMatrix.toRadian(parseFloat(document.getElementById("zoomAngle").value));

              /* Updates Projection Matrix*/
              projectionMatrix = mat4.create();
              mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
              gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
            }

            updatePerspective()


            /* Function for updating zoom based on scroll */

            function updateEyeOnScroll(event) {
              event.preventDefault(); // Prevent page from scrolling

              var zoomAngle = parseFloat(document.getElementById("zoomAngle").value);
              
              var step = 1;
          
              // Scrolling up increases zoom (moves forward), down decreases zoom (moves back)
              if (event.deltaY < 0) {
                  zoomAngle -= step;
              } else {
                  zoomAngle += step;
              }

              // Update perspective
              document.getElementById("zoomAngle").value = zoomAngle.toFixed(2);

              updatePerspective()
            }

            /* Initializes model matrix (identity) */
            modelMatrix = mat4.create();
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            /* Adds normal matrix */
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

            /* Sets up light and material parameters */
            var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 0.850, 1.0, 1.0);

            

            /* Function for changing the values of the light components (RGB) */
            function updateLightColor() {

                /* Retrieves the light components (RGB) from the input fields */
                var lightR = parseFloat(document.getElementById("lightR").value);
                var lightG = parseFloat(document.getElementById("lightG").value);
                var lightB = parseFloat(document.getElementById("lightB").value);

                var lightColor = [lightR, lightG, lightB, 1.0];

                /* Updates the light color */
                var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightColor");
                gl.uniform4fv(uLightDiffuseColorPtr, new Float32Array(lightColor));
            }

            updateLightColor()

            /* Function for changing the values of the light direction */
            function updateLightDirection() {
                var lightX = parseFloat(document.getElementById("lightX").value);
                var lightY = parseFloat(document.getElementById("lightY").value);
                var lightZ = parseFloat(document.getElementById("lightZ").value);

                var lightDirection = [lightX, lightY, lightZ, 0.0];
                
                console.log(lightX, lightY, lightZ);

                /* Updates the light direction  */
                var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
                gl.uniform4fv(uLightDirectionVectorPtr, new Float32Array(lightDirection));
            }

            updateLightDirection()


            /* Retrieve location of specular and ambient strength to update light intensity */
            var uSpecularStrengthPtr = gl.getUniformLocation(program, "uSpecularStrength");
            var uAmbientStrengthPtr = gl.getUniformLocation(program, "uAmbientStrength");

            /* Function to set light intensity based on time of day */
            var currentTime = new Date();
            var currentHour = currentTime.getHours(); 

            function updateLightIntensity(){

              // If time is between 6 AM to 5 PM, set light intensity to bright
              if(currentHour < 18 && currentHour >= 6){
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                // Change button text to NIGHT
                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }

              // If time is between 6 PM to 5 AM, set light intensity to dim
              else{
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                // Change button text to DAY
                document.querySelector("#lightingbtn").innerText = "DAY";
              }
            }
            
            updateLightIntensity();


            /* Sets up coordinates for the object */
            var vertices = [  
  
                /* Front face */
                -1.0, -1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,

                /* Back face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,

                /* Top face */
                -1.0,  1.0, -1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,

                /* Bottom face */
                -1.0, -1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,

                /* Right face */
                1.0, -1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,

                /* Left face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0
            ];


            /* Binds the vertex buffer and load data */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            
            /* Sets up the indices of the vertices */
            var indices = [
                0, 1, 2,      0, 2, 3,    
                4, 5, 6,      4, 6, 7,    
                8, 9, 10,     8, 10, 11,  
                12, 13, 14,   12, 14, 15, 
                16, 17, 18,   16, 18, 19, 
                20, 21, 22,   20, 22, 23  
            ];       


            /* Binds the index buffer and load data */
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        
            /* Sets up the normals of the vertices */
            var normals = [  
                0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,  // front
                0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,  // front
                0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,  // front
                0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,  // front
                1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,  // right
                -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0   // left
            ];

            /* Binds the normal buffer and load data */
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            /* Sets up normal attribute pointer */
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            /* Vertex buffer for waves */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);
            



            /* Variables for wave animation */
            let startTime = performance.now(); 
            let waveEnabled = false;

            /* Function for toggling rotation on button press */
            function toggleAnimation() {
              waveEnabled = !waveEnabled;

              // Update the shader uniform for wave
              const uUseWaveLocation = gl.getUniformLocation(program, 'uUseWave');
              gl.uniform1i(uUseWaveLocation, waveEnabled ? 1 : 0);

              if(waveEnabled) { document.querySelector("#animationbtn").innerText = "OFF"; }
              else if(!waveEnabled) { document.querySelector("#animationbtn").innerText = "ON"; }
            }

            window.toggleAnimation = toggleAnimation;
            
            // Calculate wave height at position (x,z) at time elapsedTime
            function getWaveHeight(x, z, elapsedTime) {
                return Math.sin(elapsedTime * 2.0 + (x + z)) * 0.5;
            }

            // Calculate wave normal at position (x,z) at time elapsedTime
            function getWaveNormal(x, z, elapsedTime) {
                // Calculate partial derivatives to get the normal
                const delta = 0.1;
                const h = getWaveHeight(x, z, elapsedTime);
                const hx = getWaveHeight(x + delta, z, elapsedTime) - h;
                const hz = getWaveHeight(x, z + delta, elapsedTime) - h;
                
                // Return normal vector (pointing upwards)
                return [-hx, 1.0, -hz];
            }

           // Draw the boat
           function renderBoat() {
            if (!mesh) return;

            // Enable texture only if we have texture coordinates
            const useTexture = mesh.hasTextureCoords && wakeboardTexture;
            gl.uniform1i(uUseTextureLocation, useTexture ? 1 : 0);
            
            if (useTexture) {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, wakeboardTexture);
                gl.uniform1i(uTextureLocation, 0);
            }

            // Save current state
            const prevArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
            const prevElementBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
            const prevPositionPointer = gl.getVertexAttrib(aPositionPointer, gl.VERTEX_ATTRIB_ARRAY_ENABLED);
            const prevNormalPointer = gl.getVertexAttrib(aNormalPointer, gl.VERTEX_ATTRIB_ARRAY_ENABLED);
            const prevTexCoordPointer = texcoordLocation !== -1 ? 
            gl.getVertexAttrib(texcoordLocation, gl.VERTEX_ATTRIB_ARRAY_ENABLED) : false;


            // Boat transformations
            let boatModelMatrix = mat4.create();
            mat4.identity(boatModelMatrix);

            // Translate
            mat4.translate(boatModelMatrix,boatModelMatrix, [gridCenterX, 2.5, gridCenterZ]);
            
            // Rotate to orient the boat facing the camera.
            mat4.rotateX(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90));
            mat4.rotateZ(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90));
            // Finally, scale
            mat4.scale(boatModelMatrix, boatModelMatrix, [0.05, 0.05, 0.05]);
            

            gl.uniformMatrix4fv(uModelMatrixPointer, false, boatModelMatrix);
            // Bind boat buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
            gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
            gl.vertexAttribPointer(aNormalPointer, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            // Bind texture coordinates if they exist
                if (mesh.hasTextureCoords && mesh.textureBuffer && texcoordLocation !== -1) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.textureBuffer);
                    gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(texcoordLocation);
                } else if (texcoordLocation !== -1) {
                    gl.disableVertexAttribArray(texcoordLocation);
                    console.log("they do not exist")
                    // Provide default texture coordinates if needed
                    gl.vertexAttrib2f(texcoordLocation, 0, 0);
                }

            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
            
            gl.drawElements(gl.TRIANGLES, mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

            // Restore previous state
            gl.bindBuffer(gl.ARRAY_BUFFER, prevArrayBuffer);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, prevElementBuffer);
            
            
            if (prevPositionPointer) {
                gl.enableVertexAttribArray(aPositionPointer);
            } else {
                gl.disableVertexAttribArray(aPositionPointer);
            }
            
            if (prevNormalPointer) {
                gl.enableVertexAttribArray(aNormalPointer);
            } else {
                gl.disableVertexAttribArray(aNormalPointer);
            }

            if (texcoordLocation !== -1) {
                if (prevTexCoordPointer) {
                    gl.enableVertexAttribArray(texcoordLocation);
                } else {
                    gl.disableVertexAttribArray(texcoordLocation);
                }
            }
            // console.log('Texture coordinates:', parsedObj.textures);
            // console.log('Texture buffer created:', !!mesh.textureBuffer);
            // console.log('Texture location:', texcoordLocation);
        }

            /* Enable the ANGLE_instanced_arrays extension */

            // Create a buffer for instance data (positions and wave heights)
            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) {
                console.error('ANGLE_instanced_arrays not supported');
                return;
            }

            /* Precalculation of wave cube instances */
            
            const instanceData = [];
            for (let i = 0; i < instanceCount; i++) {
                for (let j = 0; j < instanceCount; j++) {
                    instanceData.push(i - 5, j - 5); // Store grid positions
                }
            }
            const instanceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(instanceData), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
            gl.vertexAttribPointer(aInstancePosition, 2, gl.FLOAT, false, 0, 0);
            ext.vertexAttribDivisorANGLE(aInstancePosition, 1);
            
            // //Scaling factor
            // gl.uniform3f(uScaleLocation, 0.5, 0.5, 0.5);


                          // Draw a cube at the corner of the wave grid
              const cornerColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
              gl.uniform4f(cornerColorPtr, 1.0, 0.0, 0.0, 1.0); // Red cube

              // Setup model matrix for the corner cube
              let cornerModelMatrix = mat4.create();
              const offsetX = -5;
              const offsetY = -5;
              mat4.translate(cornerModelMatrix, cornerModelMatrix, [offsetX, offsetY, 0]);
              mat4.scale(cornerModelMatrix, cornerModelMatrix, [0.5, 0.5, 0.5]); // Same scale as wave cubes

              // Pass to shader
              gl.uniformMatrix4fv(uModelMatrixPointer, false, cornerModelMatrix);

              // Use same cube geometry buffers
              gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
              gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

              gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
              gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);

              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

              // Disable instancing for this one cube
              ext.vertexAttribDivisorANGLE(aInstancePosition, 0);

              // Draw the cube (just once)
              gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);

              // Restore instancing divisor
              ext.vertexAttribDivisorANGLE(aInstancePosition, 1);



function render() {
    const elapsedTime = performance.now() / 2000;


    // Update time uniform
    const uTimeLocation = gl.getUniformLocation(program, 'uTime');
    gl.uniform1f(uTimeLocation, elapsedTime);

    // Clear screen
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // === Wave cubes ===
    var waveModelMatrix = mat4.create();
    mat4.scale(waveModelMatrix, waveModelMatrix, [0.5, 0.5, 0.5]);
    gl.uniformMatrix4fv(uModelMatrixPointer, false, waveModelMatrix);

    gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
    gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    ext.drawElementsInstancedANGLE(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0, instanceCount * instanceCount);

    // === Boat ===
    const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
    const originalColor = [0.0, 0.850, 1.0, 1.0];

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, wakeboardTexture);
    gl.uniform1i(uTextureLocation, 0);
    gl.uniform1i(uUseTextureLocation, true);

    gl.uniform4f(originalColorPtr, 0.7, 0.7, 0.7, 1.0); // Boat color
    renderBoat();
    gl.uniform4fv(originalColorPtr, new Float32Array(originalColor)); // Reset color

    // Loop
    requestAnimationFrame(render);
}




            render();

            if(currentHour < 18 && currentHour >= 6){
              var daylight = true; 
            }
            else{
              var daylight = false;
            }
            

            function toggleLighting() {
              daylight = !daylight;

              if(daylight){
                // Change background to white
                gl.clearColor(0.0, 0.0, 0.0, 0.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }
              else{
                 // Change background to dark gray
                gl.clearColor(0.3, 0.3, 0.3, 1.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                document.querySelector("#lightingbtn").innerText = "DAY";
              }

              // Update light after setting values
              updateLightDirection();
            };

            window.toggleLighting = toggleLighting;
            
            

            /* Retrieves values of the input sliders */
            document.getElementById("eyeX").addEventListener("input", updateEyePosition);
            document.getElementById("eyeY").addEventListener("input", updateEyePosition);
            document.getElementById("eyeZ").addEventListener("input", updateEyePosition);

            document.getElementById("lightX").addEventListener("input", updateLightDirection);
            document.getElementById("lightY").addEventListener("input", updateLightDirection);
            document.getElementById("lightZ").addEventListener("input", updateLightDirection);

            document.getElementById("lightR").addEventListener("input", updateLightColor);
            document.getElementById("lightG").addEventListener("input", updateLightColor);
            document.getElementById("lightB").addEventListener("input", updateLightColor);

            document.getElementById("zoomAngle").addEventListener("input", updatePerspective);

            /* Event Listeners for input */
            document.addEventListener('wheel', updateEyeOnScroll, { passive: false });
            document.addEventListener('keydown', updateEyeOnKeydown);

            
              
        }

    
    </script>

  </head>

  <body onload="main()">
    <div class="container">
  
      <!-- Sidebar -->
      <div class="sidebar">
        <img src="boats-logo.PNG" alt="Wave Simulation" class="logo">
  
        <label class="section-title-btn">SIMULATE WAVE</label>
        <button id="animationbtn" onclick="toggleAnimation()">ON</button>
  
        <div class="section">
          <label class="section-title">EYE POSITION</label>

          <label for="eyeX">X</label>
          <input type="range" id="eyeX" step="0.1" min="0" max="100" value="80"><br/>
  
          <label for="eyeY">Y</label>
          <input type="range" id="eyeY" step="0.1" min="-20" max="100" value="25"><br/>
  
          <label for="eyeZ">Z</label>
          <input type="range" id="eyeZ" step="0.1" min="-20" max="100" value="80"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">ZOOM</label>
          <label for="zoomAngle">Z</label>
          <input type="range" id="zoomAngle" step="0.1" min="-20" max="100" value="30">
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT DIRECTION</label>

          <label for="lightX">X</label>
          <input type="range" id="lightX" step="0.1" min="-20" max="20" value="1.0"><br/>
  
          <label for="lightY">Y</label>
          <input type="range" id="lightY" step="0.1" min="-20" max="20" value="3.0"><br/>
  
          <label for="lightZ">Z</label>
          <input type="range" id="lightZ" step="0.1" min="-20" max="20" value="5.0"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT COLOR</label>
          <label for="lightR" class="color-label red">R</label>
          <input type="range" id="lightR" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightG" class="color-label green">G</label>
          <input type="range" id="lightG" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightB" class="color-label blue">B</label>
          <input type="range" id="lightB" step="0.05" min="0" max="1" value="1"><br/>
        </div>
  
        <label class="section-title-btn">SET TIME TO </label>
        <button id="lightingbtn" onclick="toggleLighting()">DAY</button>
      </div>
  
      <!-- Canvas area -->
      <div class="canvas-container">
        <canvas id="main_canvas" width="1600" height="900"></canvas>
      </div>
  
    </div>
  </body>

</html>



<!-- REFERENCES -->

<!-- 1 | Wave Animation -->
<!-- https://stackoverflow.com/questions/23417139/programmatically-make-a-wave-using-javascript -->
<!-- https://gist.github.com/gkhays/e264009c0832c73d5345847e673a64ab -->
 <!--https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html-->