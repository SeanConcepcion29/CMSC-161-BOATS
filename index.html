<!DOCTYPE html>
<html>
  <head>
    <title> B.O.A.T.S. </title>
    <link rel="stylesheet" href="styles.css">

    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;
         

      attribute vec2 aInstancePosition;
      uniform float uTime;
      // uniform vec3 uScale; 

      uniform bool uUseWave;


      uniform mat4 uModelMatrix;                
      uniform mat4 uViewMatrix;                 
      uniform mat4 uProjectionMatrix;           

      uniform mat4 uNormalMatrix;              
      
      uniform vec4 uMaterialDiffuseColor;     
      uniform vec4 uMaterialSpecularColor;  
      uniform vec4 uMaterialAmbientColor;     

      uniform vec4 uLightColor;    

      uniform vec4 uLightDirectionVector;      
      uniform vec4 uEyeVector;                 
      uniform vec4 uReflectedLightVector;    
      
      uniform float uSpecularStrength;
      uniform float uAmbientStrength;

      varying vec4 vAmbientColor;

      varying vec4 vSpecularColor;

      varying vec4 vDiffuseColor;

      void main() {

        // Calculate wave height based on whether it is on or not.
        float waveHeight = uUseWave ? sin(uTime * 2.0 + (aInstancePosition.x + aInstancePosition.y)) * 0.5 : 0.0;

        // Apply instance position and wave height
        vec4 instancePosition = vec4(aInstancePosition.x, waveHeight, aInstancePosition.y, 1.0);
        mat4 modelMatrix = uModelMatrix;
        modelMatrix[3] = instancePosition;

        // Create instance translation
        mat4 instanceTranslate = mat4(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          aInstancePosition.x, waveHeight, aInstancePosition.y, 1.0
        );

        // Apply scaling
        /*mat4 scaleMatrix = mat4(
          uScale.x, 0.0, 0.0, 0.0,
          0.0, uScale.y, 0.0, 0.0,
          0.0, 0.0, uScale.z, 0.0,
          0.0, 0.0, 0.0, 1.0
        );*/
        // modelMatrix = modelMatrix * scaleMatrix;

        // Transform vertex position
        gl_Position = uProjectionMatrix * uViewMatrix * modelMatrix * aPosition;
          
        //Ambient
        vec4 ambient = uAmbientStrength * uLightColor;

        //Diffuse
        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);
        float lambertCoefficient = max(dot(normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        //Specular
        vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
        vec4 normalized_uEyeVector = normalize(-viewPos); 
        vec4 normalized_uReflectedLightVector = normalize(2.0 * dot(normalized_uLightDirectionVector,normalized_aNormalVector) * normalized_aNormalVector - normalized_uLightDirectionVector);
        float specularAngle = max(dot(normalized_uEyeVector,normalized_uReflectedLightVector),0.0);
        float specular = pow(specularAngle, 16.0);

        vec4 ambientColor = ambient * uLightColor * uMaterialDiffuseColor;
        vec4 specularColor = uSpecularStrength * specular * uLightColor * uMaterialDiffuseColor;
        vec4 diffuseColor =  lambertCoefficient * uLightColor * uMaterialDiffuseColor ;
        
        vAmbientColor = vec4(ambientColor.r, ambientColor.g, ambientColor.b, 1.0);
        vSpecularColor = vec4(specularColor.r, specularColor.g, specularColor.b, 1.0);
        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);

      }
    </script>


    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fshader">

      precision mediump float;
      varying vec4 vDiffuseColor;
      varying vec4 vSpecularColor;
      varying vec4 vAmbientColor;

      void main() {
        gl_FragColor = vAmbientColor + vDiffuseColor + vSpecularColor;
        
      }

    </script>
    <!-- Imports external javascript file -->
    <!-- Helper javascript methods for initializing webgl -->
    <script src="lib/webgl-init.js"></script>
    <script src="lib/webgl-utils.js"></script>
    <script src="lib/webgl-debug.js"></script>
    <script src="lib/gl-matrix-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/webgl-obj-loader@2.0.8/dist/webgl-obj-loader.min.js"></script>


    <!-- Applies Poppins font to the entire body -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500&display=swap" rel="stylesheet">
    <style> body { font-family: 'Poppins', sans-serif;} </style>


    <!-- FUNCTIONS & MAIN PROGRAM -->
    <script>

        // Global variables for boat position and movement
        var boatPosition = { x: 0, y: 0, z: 0 };
        var boatSpeed = 0.1;
        var boatRotation = 0; // Rotation angle in radians
        // Global variable to hold the boat mesh.
        var mesh = null;

        // Function to load the OBJ file
        function loadWakeboard(gl) {
            var objStr = '';
            fetch('models/wakeboard.obj')
                .then(response => response.text())
                .then(text => {
                    // Parse the OBJ file
                    var parsedObj = new OBJ.Mesh(text);
                    // Initialize WebGL buffers
                    mesh = OBJ.initMeshBuffers(gl, parsedObj);
                })
                .catch(error => console.error('Error loading OBJ file:', error));
        }
        
        /* MAIN PROGRAM */
        function main() {
        
            var canvas = document.getElementById("main_canvas");


            if (!canvas) {
                console.log("Failed to retrieve the <canvas> element");
            }

            /* Sets up the WebGL rendering context */
            var gl = initializeWebGL(canvas, true);

            loadWakeboard(gl); //initialize mesh

            /* Loads shaders */ 
            var vertexShader = initializeShader(gl, "vshader");
            var fragmentShader = initializeShader(gl, "fshader");

            /* Creates and sets the program created earlier */
            var program = initializeProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            /* Creates and links program */
            var aPositionPointer = gl.getAttribLocation(program, "aPosition");
            gl.enableVertexAttribArray(aPositionPointer);

            var aNormalPointer = gl.getAttribLocation(program, "aNormal");
            gl.enableVertexAttribArray(aNormalPointer);

            /* Retrieves the location of the model, view, and projection from the shader program */
            var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
            var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
            var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
            var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");
            
            
            const aInstancePosition = gl.getAttribLocation(program, 'aInstancePosition');
            gl.enableVertexAttribArray(aInstancePosition);
            
            // const uScaleLocation = gl.getUniformLocation(program, "uScale");
            // gl.uniform3f(uScaleLocation, 0.5, 0.5, 0.5);
            
            var waveModelMatrix = mat4.create();
            mat4.scale(waveModelMatrix, waveModelMatrix, [0.5, 0.5, 0.5]); // Scale waves
            gl.uniformMatrix4fv(uModelMatrixPointer, false, waveModelMatrix);


            var modelMatrix = mat4.create();
            var viewMatrix;
            var projectionMatrix;

            /* Makes the screen transparent */
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            /* Enable depth testing */
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.DEPTH_BUFFER_BIT);


            /* Sets up projection matrix specification */
            var fieldOfViewYAxis = glMatrix.toRadian(30);
            var aspectRatio = canvas.width / canvas.height;
            var nearPlane = 1;
            var farPlane = 200;

            projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
            gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));

            /* Number of Wave Cubes Instanced */
            const instanceCount = 80;

            /* Sets up view matrix specification */

            // Dynamically calculate the center of the grid based on instanceCount
            const gridCenterX = (instanceCount - 1) / 2; // Center of the grid along X
            const gridCenterZ = (instanceCount - 1) / 2; // Center of the grid along Z
            var lookAtPoint = [gridCenterX - 5, 0.0, gridCenterZ - 5]; // Adjust for grid offset
            var upVector = [0.0, 1.0, 0.0, 0.0]; 



            /* Function for changing the values of the view position */
            function updateEyePosition() {

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var eyePoint = [eyeX, eyeY, eyeZ, 1.0]; 

                /* Updates the view matrix */
                viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
                gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
            }

            updateEyePosition();

            /* Function for updating eye postion based on key press */
            function updateEyeOnKeydown(event){

                /* Retrieves the eye position from the input fields */
                var eyeX = parseFloat(document.getElementById("eyeX").value);
                var eyeY = parseFloat(document.getElementById("eyeY").value);
                var eyeZ = parseFloat(document.getElementById("eyeZ").value);

                var step = 1;

                switch (event.key) {
                  case 'ArrowLeft':   // Move left (along X-axis)
                      eyeX -= step;
                      break;
                  case 'ArrowRight':  // Move right
                      eyeX += step;
                      break;
                  case 'ArrowUp':     // Move up (along Y-axis)
                      eyeY += step;
                      break;
                  case 'ArrowDown':   // Move down
                      eyeY -= step;
                      break;
                }

                /* Update input values in HTML */
                document.getElementById("eyeX").value = eyeX.toFixed(2);
                document.getElementById("eyeY").value = eyeY.toFixed(2);

                updateEyePosition();
            }

            /* Function for updating projection matrix */
            function updatePerspective(){
              /* Retrieves perspective from the input fields */
              fieldOfViewYAxis = glMatrix.toRadian(parseFloat(document.getElementById("zoomAngle").value));

              /* Updates Projection Matrix*/
              projectionMatrix = mat4.create();
              mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
              gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
            }

            updatePerspective()


            /* Function for updating zoom based on scroll */

            function updateEyeOnScroll(event) {
              event.preventDefault(); // Prevent page from scrolling

              var zoomAngle = parseFloat(document.getElementById("zoomAngle").value);
              
              var step = 1;
          
              // Scrolling up increases zoom (moves forward), down decreases zoom (moves back)
              if (event.deltaY < 0) {
                  zoomAngle -= step;
              } else {
                  zoomAngle += step;
              }

              // Update perspective
              document.getElementById("zoomAngle").value = zoomAngle.toFixed(2);

              updatePerspective()
            }

            /* Initializes model matrix (identity) */
            modelMatrix = mat4.create();
            gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

            /* Adds normal matrix */
            var normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

            /* Sets up light and material parameters */
            var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
            gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 0.850, 1.0, 1.0);

            

            /* Function for changing the values of the light components (RGB) */
            function updateLightColor() {

                /* Retrieves the light components (RGB) from the input fields */
                var lightR = parseFloat(document.getElementById("lightR").value);
                var lightG = parseFloat(document.getElementById("lightG").value);
                var lightB = parseFloat(document.getElementById("lightB").value);

                var lightColor = [lightR, lightG, lightB, 1.0];

                /* Updates the light color */
                var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightColor");
                gl.uniform4fv(uLightDiffuseColorPtr, new Float32Array(lightColor));
            }

            updateLightColor()

            /* Function for changing the values of the light direction */
            function updateLightDirection() {
                var lightX = parseFloat(document.getElementById("lightX").value);
                var lightY = parseFloat(document.getElementById("lightY").value);
                var lightZ = parseFloat(document.getElementById("lightZ").value);

                var lightDirection = [lightX, lightY, lightZ, 0.0];
                
                console.log(lightX, lightY, lightZ);

                /* Updates the light direction  */
                var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
                gl.uniform4fv(uLightDirectionVectorPtr, new Float32Array(lightDirection));
            }

            updateLightDirection()


            /* Retrieve location of specular and ambient strength to update light intensity */
            var uSpecularStrengthPtr = gl.getUniformLocation(program, "uSpecularStrength");
            var uAmbientStrengthPtr = gl.getUniformLocation(program, "uAmbientStrength");

            /* Function to set light intensity based on time of day */
            var currentTime = new Date();
            var currentHour = currentTime.getHours(); 

            function updateLightIntensity(){

              // If time is between 6 AM to 5 PM, set light intensity to bright
              if(currentHour < 18 && currentHour >= 6){
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                // Change button text to NIGHT
                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }

              // If time is between 6 PM to 5 AM, set light intensity to dim
              else{
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                // Change button text to DAY
                document.querySelector("#lightingbtn").innerText = "DAY";
              }
            }
            
            updateLightIntensity();


            /* Sets up coordinates for the object */
            var vertices = [  
    
                /* Front face */
                -1.0, -1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,

                /* Back face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,

                /* Top face */
                -1.0,  1.0, -1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,

                /* Bottom face */
                -1.0, -1.0, -1.0, 1.0,
                1.0, -1.0, -1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,

                /* Right face */
                1.0, -1.0, -1.0, 1.0,
                1.0,  1.0, -1.0, 1.0,
                1.0,  1.0,  1.0, 1.0,
                1.0, -1.0,  1.0, 1.0,

                /* Left face */
                -1.0, -1.0, -1.0, 1.0,
                -1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  1.0, 1.0,
                -1.0,  1.0, -1.0, 1.0
            ];


            /* Binds the vertex buffer and load data */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            
            /* Sets up the indices of the vertices */
            var indices = [
                0, 1, 2,      0, 2, 3,    
                4, 5, 6,      4, 6, 7,    
                8, 9, 10,     8, 10, 11,  
                12, 13, 14,   12, 14, 15, 
                16, 17, 18,   16, 18, 19, 
                20, 21, 22,   20, 22, 23  
            ];       


            /* Binds the index buffer and load data */
            var indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        
            /* Sets up the normals of the vertices */
            var normals = [  
                0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,     0.0, 0.0, 1.0, 0.0,  // front
                0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,    0.0, 0.0, -1.0, 0.0,  // front
                0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,     0.0, 1.0, 0.0, 0.0,  // front
                0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,    0.0, -1.0, 0.0, 0.0,  // front
                1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,     1.0, 0.0, 0.0, 0.0,  // right
                -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0,    -1.0, 0.0, 0.0, 0.0   // left
            ];

            /* Binds the normal buffer and load data */
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            /* Sets up normal attribute pointer */
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            /* Vertex buffer for waves */
            var verticesBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            /* Sets up vertex attribute pointer */
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);
            



            /* Variables for wave animation */
            let startTime = performance.now(); 
            let waveEnabled = false;

            /* Function for toggling rotation on button press */
            function toggleAnimation() {
              waveEnabled = !waveEnabled;

              // Update the shader uniform for wave
              const uUseWaveLocation = gl.getUniformLocation(program, 'uUseWave');
              gl.uniform1i(uUseWaveLocation, waveEnabled ? 1 : 0);

              if(waveEnabled) { document.querySelector("#animationbtn").innerText = "OFF"; }
              else if(!waveEnabled) { document.querySelector("#animationbtn").innerText = "ON"; }
            }

            window.toggleAnimation = toggleAnimation;
            
            // Calculate wave height at position (x,z) at time elapsedTime
            function getWaveHeight(x, z, elapsedTime) {
                return Math.sin(elapsedTime * 2.0 + (x + z)) * 0.5;
            }

            // Calculate wave normal at position (x,z) at time elapsedTime
            function getWaveNormal(x, z, elapsedTime) {
                // Calculate partial derivatives to get the normal
                const delta = 0.1;
                const h = getWaveHeight(x, z, elapsedTime);
                const hx = getWaveHeight(x + delta, z, elapsedTime) - h;
                const hz = getWaveHeight(x, z + delta, elapsedTime) - h;
                
                // Return normal vector (pointing upwards)
                return [-hx, 1.0, -hz];
            }

           // Draw the boat
           function renderBoat() {
              if (!mesh) return;

              // Save current state
              const prevArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
              const prevElementBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
              const prevPositionPointer = gl.getVertexAttrib(aPositionPointer, gl.VERTEX_ATTRIB_ARRAY_ENABLED);
              const prevNormalPointer = gl.getVertexAttrib(aNormalPointer, gl.VERTEX_ATTRIB_ARRAY_ENABLED);

              // Boat transformations
              let boatModelMatrix = mat4.create();
              
              // Position the boat relative to wave grid center
              const gridOffsetX = (instanceCount - 1) / 2 - 5;
              const gridOffsetZ = (instanceCount - 1) / 2 - 5;
              
              // Calculate wave height at boat position for realistic floating
              const elapsedTime = performance.now() / 1000;
              const waveHeight = waveEnabled ? 
                  getWaveHeight(boatPosition.x + gridOffsetX, boatPosition.z + gridOffsetZ, elapsedTime) * 0.5 : 0;
              
              // Translate to position (including wave height)
              mat4.translate(boatModelMatrix, boatModelMatrix, [
                  boatPosition.x + gridOffsetX, 
                  0,
                  boatPosition.z + gridOffsetZ
              ]);
              
              // Rotate based on movement direction
              mat4.rotateY(boatModelMatrix, boatModelMatrix, boatRotation);
              
              // Initial orientation adjustments
              mat4.rotateX(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90)); // Tilt forward
              mat4.rotateZ(boatModelMatrix, boatModelMatrix, glMatrix.toRadian(-90)); // Face along Z
              
              // Scale the boat down
              mat4.scale(boatModelMatrix, boatModelMatrix, [0.05, 0.05, 0.05]);

              // Update normal matrix for lighting
              var normalMatrix = mat4.create();
              mat4.invert(normalMatrix, boatModelMatrix);
              mat4.transpose(normalMatrix, normalMatrix);
              gl.uniformMatrix4fv(uNormalMatrixPtr, false, normalMatrix);
              
              // Set the model matrix for the boat only
              gl.uniformMatrix4fv(uModelMatrixPointer, false, boatModelMatrix);

              // Bind boat buffers
              gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
              gl.vertexAttribPointer(aPositionPointer, 3, gl.FLOAT, false, 0, 0);
              gl.enableVertexAttribArray(aPositionPointer);
              
              gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
              gl.vertexAttribPointer(aNormalPointer, 3, gl.FLOAT, false, 0, 0);
              gl.enableVertexAttribArray(aNormalPointer);
              
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
              gl.drawElements(gl.TRIANGLES, mesh.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

              // Restore previous state
              gl.bindBuffer(gl.ARRAY_BUFFER, prevArrayBuffer);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, prevElementBuffer);
              
              if (prevPositionPointer) {
                  gl.enableVertexAttribArray(aPositionPointer);
              } else {
                  gl.disableVertexAttribArray(aPositionPointer);
              }
              
              if (prevNormalPointer) {
                  gl.enableVertexAttribArray(aNormalPointer);
              } else {
                  gl.disableVertexAttribArray(aNormalPointer);
              }
          }

          function handleBoatMovement(event) {
            // Don't interfere with camera controls
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(event.key)) {
                event.preventDefault();
            }

            switch (event.key) {
                case 'ArrowUp': // Move forward
                    boatPosition.x -= Math.sin(boatRotation) * boatSpeed;
                    boatPosition.z -= Math.cos(boatRotation) * boatSpeed;
                    break;
                case 'ArrowDown': // Move backward
                    boatPosition.x += Math.sin(boatRotation) * boatSpeed;
                    boatPosition.z += Math.cos(boatRotation) * boatSpeed;
                    break;
                case 'ArrowLeft': // Turn left
                    boatRotation += 0.05;
                    break;
                case 'ArrowRight': // Turn right
                    boatRotation -= 0.05;
                    break;
            }

            // Optional: Add boundaries to keep boat within water area
            const boundary = instanceCount / 2;
            boatPosition.x = Math.max(-boundary, Math.min(boundary, boatPosition.x));
            boatPosition.z = Math.max(-boundary, Math.min(boundary, boatPosition.z));
        }

            /* Enable the ANGLE_instanced_arrays extension */

            // Create a buffer for instance data (positions and wave heights)
            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) {
                console.error('ANGLE_instanced_arrays not supported');
                return;
            }

            /* Precalculation of wave cube instances */
            
            const instanceData = [];
            for (let i = 0; i < instanceCount; i++) {
                for (let j = 0; j < instanceCount; j++) {
                    instanceData.push(i - 5, j - 5); // Store grid positions
                }
            }
            const instanceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(instanceData), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
            gl.vertexAttribPointer(aInstancePosition, 2, gl.FLOAT, false, 0, 0);
            ext.vertexAttribDivisorANGLE(aInstancePosition, 1); // One instance per position
            
            // //Scaling factor
            // gl.uniform3f(uScaleLocation, 0.5, 0.5, 0.5);

            /* Function for rendering the objects on canvas*/
            function render() {
                
                const elapsedTime = performance.now() / 1000;

                /* Update the time uniform */
                const uTimeLocation = gl.getUniformLocation(program, 'uTime');
                gl.uniform1f(uTimeLocation, elapsedTime);

                /* Clears screen */
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Reset model matrix to identity
                var modelMatrix = mat4.create();
                

                /* Now draw the wave cubes */
                gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
                gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                // wave model matrix
                var waveModelMatrix = mat4.create();
                mat4.scale(waveModelMatrix, waveModelMatrix, [0.5, 0.5, 0.5]);
                gl.uniformMatrix4fv(uModelMatrixPointer, false, waveModelMatrix);

                ext.drawElementsInstancedANGLE(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0, instanceCount * instanceCount);

                const originalColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
                const originalColor = [0.0, 0.850, 1.0, 1.0];
                gl.uniform4f(originalColorPtr, 0.7, 0.7, 0.7, 1.0); // Boat color
                renderBoat(/*elapsedTime*/);
                gl.uniform4fv(originalColorPtr, new Float32Array(originalColor)); // Reset color

                requestAnimationFrame(render);
            }

            render();

            if(currentHour < 18 && currentHour >= 6){
              var daylight = true; 
            }
            else{
              var daylight = false;
            }
            

            function toggleLighting() {
              daylight = !daylight;

              if(daylight){
                // Change background to white
                gl.clearColor(0.0, 0.0, 0.0, 0.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.8);
                gl.uniform1f(uAmbientStrengthPtr, 0.3);

                document.querySelector("#lightingbtn").innerText = "NIGHT";
              }
              else{
                 // Change background to dark gray
                gl.clearColor(0.3, 0.3, 0.3, 1.0);

                // Change light intensity
                gl.uniform1f(uSpecularStrengthPtr, 0.5);
                gl.uniform1f(uAmbientStrengthPtr, 0.05);

                document.querySelector("#lightingbtn").innerText = "DAY";
              }

              // Update light after setting values
              updateLightDirection();
            };

            window.toggleLighting = toggleLighting;
            
            

            /* Retrieves values of the input sliders */
            document.getElementById("eyeX").addEventListener("input", updateEyePosition);
            document.getElementById("eyeY").addEventListener("input", updateEyePosition);
            document.getElementById("eyeZ").addEventListener("input", updateEyePosition);

            document.getElementById("lightX").addEventListener("input", updateLightDirection);
            document.getElementById("lightY").addEventListener("input", updateLightDirection);
            document.getElementById("lightZ").addEventListener("input", updateLightDirection);

            document.getElementById("lightR").addEventListener("input", updateLightColor);
            document.getElementById("lightG").addEventListener("input", updateLightColor);
            document.getElementById("lightB").addEventListener("input", updateLightColor);

            document.getElementById("zoomAngle").addEventListener("input", updatePerspective);

            /* Event Listeners for input */
            document.addEventListener('keydown', updateEyeOnKeydown)
            document.addEventListener('wheel', updateEyeOnScroll, { passive: false });

            // Add boat movement controls
            document.addEventListener('keydown', handleBoatMovement);

            // Modify existing camera controls to require Shift key
            document.addEventListener('keydown', updateEyeOnKeydown);

            
              
        }

    
    </script>

  </head>

  <body onload="main()">
    <div class="container">
  
      <!-- Sidebar -->
      <div class="sidebar">
        <img src="boats-logo.PNG" alt="Wave Simulation" class="logo">
  
        <label class="section-title-btn">SIMULATE WAVE</label>
        <button id="animationbtn" onclick="toggleAnimation()">ON</button>
  
        <div class="section">
          <label class="section-title">EYE POSITION</label>

          <label for="eyeX">X</label>
          <input type="range" id="eyeX" step="0.1" min="0" max="50" value="25"><br/>
  
          <label for="eyeY">Y</label>
          <input type="range" id="eyeY" step="0.1" min="-20" max="20" value="17"><br/>
  
          <label for="eyeZ">Z</label>
          <input type="range" id="eyeZ" step="0.1" min="-20" max="100" value="100"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">ZOOM</label>
          <label for="zoomAngle">Z</label>
          <input type="range" id="zoomAngle" step="0.1" min="-20" max="100" value="20">
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT DIRECTION</label>

          <label for="lightX">X</label>
          <input type="range" id="lightX" step="0.1" min="-20" max="20" value="1.0"><br/>
  
          <label for="lightY">Y</label>
          <input type="range" id="lightY" step="0.1" min="-20" max="20" value="3.0"><br/>
  
          <label for="lightZ">Z</label>
          <input type="range" id="lightZ" step="0.1" min="-20" max="20" value="5.0"><br/>
        </div>
  
        <div class="section">
          <label class="section-title">LIGHT COLOR</label>
          <label for="lightR" class="color-label red">R</label>
          <input type="range" id="lightR" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightG" class="color-label green">G</label>
          <input type="range" id="lightG" step="0.05" min="0" max="1" value="1"><br/>
  
          <label for="lightB" class="color-label blue">B</label>
          <input type="range" id="lightB" step="0.05" min="0" max="1" value="1"><br/>
        </div>
  
        <label class="section-title-btn">SET TIME TO </label>
        <button id="lightingbtn" onclick="toggleLighting()">DAY</button>
      </div>
  
      <!-- Canvas area -->
      <div class="canvas-container">
        <canvas id="main_canvas" width="1600" height="900"></canvas>
      </div>
  
    </div>
  </body>

</html>



<!-- REFERENCES -->

<!-- 1 | Wave Animation -->
<!-- https://stackoverflow.com/questions/23417139/programmatically-make-a-wave-using-javascript -->
<!-- https://gist.github.com/gkhays/e264009c0832c73d5345847e673a64ab -->